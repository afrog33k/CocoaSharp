using ObjectiveC;using System;using SharpSwift.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// The NSString class declares the programmatic interface for an object that manages immutable strings. An immutable string is a text string that is defined when it is created and subsequently cannot be changed. NSString is implemented to represent an array of Unicode characters, in other words, a text string.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/cl/NSString"/>    [iOSVersion(2)]    //TODO: check circular dependency, why is NSString inherited from NSMutableString? wtf    public class NSString// : NSMutableString//, AnyObject, NSCoding, NSCopying, NSMutableCopying, NSObjectProtocol, NSSecureCoding, Reflectable, StringLiteralConvertible    {        /// <summary>        /// Returns an initialized NSString object that contains no characters.        /// </summary>        [iOSVersion(2)]        public NSString() { }                /// <summary>        /// Returns an initialized NSString object containing a given number of bytes from a given buffer of bytes interpreted in a given encoding.        /// </summary>        /// <param name="bytes">A buffer of bytes interpreted in the encoding specified by encoding.</param>        /// <param name="length">The number of bytes to use from bytes.</param>        /// <param name="encoding">The character encoding applied to bytes.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(ConstUnsafePointer<Action> bytes, int length, uint encoding) { }                /// <summary>        /// Returns an initialized NSString object that contains a given number of bytes from a given buffer of bytes interpreted in a given encoding, and optionally frees the buffer.        /// </summary>        /// <param name="bytesNoCopy">A buffer of bytes interpreted in the encoding specified by encoding.</param>        /// <param name="length">The number of bytes to use from bytes.</param>        /// <param name="encoding">The character encoding of bytes.</param>        /// <param name="freeWhenDone">If true, the receiver frees the memory when it no longer needs the data; if false it won’t.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(UnsafePointer<Action> bytesNoCopy, int length, uint encoding, bool freeWhenDone) { }                /// <summary>        /// Returns an initialized NSString object that contains a given number of characters from a given C array of Unicode characters.        /// </summary>        /// <param name="characters">A C array of Unicode characters; the value must not be NULL.        ///     Important        ///     Raises an exception if characters is NULL, even if length is 0.</param>        /// <param name="length">The number of characters to use from characters.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(ConstUnsafePointer<unichar> characters, int length) { }                /// <summary>        /// Returns an initialized NSString object that contains a given number of characters from a given C array of Unicode characters.        /// </summary>        /// <param name="charactersNoCopy">A C array of Unicode characters.</param>        /// <param name="length">The number of characters to use from characters.</param>        /// <param name="freeWhenDone">If true, the receiver will free the memory when it no longer needs the characters; if false it won’t.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(UnsafePointer<unichar> charactersNoCopy, int length, bool freeWhenDone) { }                /// <summary>        /// Returns an NSString object initialized by copying the characters from another given string.        /// </summary>        /// <param name="@string">The string from which to copy characters. This value must not be nil.        ///     Important        ///     Raises an NSInvalidArgumentException if aString is nil.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(string @string) { }                /// <summary>        /// Returns an NSString object initialized using the characters in a given C array, interpreted according to a given encoding.        /// </summary>        /// <param name="CString">A C array of characters. The array must end with a NULL character; intermediate NULL characters are not allowed.</param>        /// <param name="encoding">The encoding of nullTerminatedCString.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(ConstUnsafePointer<Int8> CString, uint encoding) { }                /// <summary>        /// Returns an NSString object initialized by copying the characters from a given C array of UTF8-encoded bytes.        /// </summary>        /// <param name="UTF8String">A NULL-terminated C array of bytes in UTF-8 encoding. This value must not be NULL.        ///     Important        ///     Raises an exception if bytes is NULL.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(ConstUnsafePointer<Int8> UTF8String) { }                /// <summary>        /// Returns an NSString object initialized by using a given format string as a template into which the remaining argument values are substituted according to the current locale.        /// </summary>        /// <param name="format">A format string. See Formatting String Objects for examples of how to use this method, and String Format Specifiers for a list of format specifiers. This value must not be nil.        ///     Important        ///     Raises an NSInvalidArgumentException if format is nil.</param>        /// <param name="arguments">A list of arguments to substitute into format.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(string format, CVaListPointer arguments) { }                /// <summary>        /// Returns an NSString object initialized by using a given format string as a template into which the remaining argument values are substituted according to given locale information.        /// </summary>        /// <param name="format">A format string. See Formatting String Objects for examples of how to use this method, and String Format Specifiers for a list of format specifiers. This value must not be nil.        ///     Important        ///     Raises an NSInvalidArgumentException if format is nil.</param>        /// <param name="locale">An NSLocale object specifying the locale to use. To use the current locale (specified by user preferences), pass [NSLocalecurrentLocale]. To use the system locale, pass nil.         ///   For legacy support, this may be an instance of NSDictionary containing locale information.</param>        /// <param name="arguments">A list of arguments to substitute into format.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(string format, AnyObject locale, CVaListPointer arguments) { }                /// <summary>        /// Returns an NSString object initialized by converting given data into Unicode characters using a given encoding.        /// </summary>        /// <param name="data">An NSData object containing bytes in encoding and the default plain text format (that is, pure content with no attributes or other markups) for that encoding.</param>        /// <param name="encoding">The encoding used by data.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(NSData data, uint encoding) { }                /// <summary>        /// Returns a string containing a given number of characters taken from a given C array of Unicode characters.        /// </summary>        /// <param name="chars">A C array of Unicode characters; the value must not be NULL.        ///     Important        ///     Raises an exception if chars is NULL, even if length is 0.</param>        /// <param name="length">The number of characters to use from chars.</param>        [iOSVersion(2)]        [Export("stringWithCharacters")]        public static NSString StringWithCharacters(ConstUnsafePointer<unichar> chars, int length) { return default(NSString); }                /// <summary>        /// Returns a string created by copying the characters from another given string.        /// </summary>        /// <param name="aString">The string from which to copy characters. This value must not be nil.        ///     Important        ///     Raises an NSInvalidArgumentException if aString is nil.</param>        [iOSVersion(2)]        [Export("stringWithString")]        public static NSString StringWithString(string aString) { return default(NSString); }                /// <summary>        /// Returns a string containing the bytes in a given C array, interpreted according to a given encoding.        /// </summary>        /// <param name="cString">A C array of bytes. The array must end with a NULL byte; intermediate NULL bytes are not allowed.</param>        /// <param name="encoding">The encoding of cString.</param>        [iOSVersion(2)]        [Export("stringWithCString")]        public static NSString StringWithCString(ConstUnsafePointer<Int8> cString, uint encoding) { return default(NSString); }                /// <summary>        /// Returns a string created by copying the data from a given C array of UTF8-encoded bytes.        /// </summary>        /// <param name="bytes">A NULL-terminated C array of bytes in UTF8 encoding.         ///     Important        ///     Raises an exception if bytes is NULL.</param>        [iOSVersion(2)]        [Export("stringWithUTF8String")]        public static NSString StringWithUTF8String(ConstUnsafePointer<Int8> bytes) { return default(NSString); }                /// <summary>        /// Returns a string created by reading data from the file at a given path interpreted using a given encoding.        /// </summary>        /// <param name="path">A path to a file.</param>        /// <param name="encoding">The encoding of the file at path.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, pass in NULL.</param>        [iOSVersion(2)]        [Export("stringWithContentsOfFile")]        public static NSString StringWithContentsOfFile(string path, uint encoding, NSErrorPointer error) { return default(NSString); }                /// <summary>        /// Returns an NSString object initialized by reading data from the file at a given path using a given encoding.        /// </summary>        /// <param name="contentsOfFile">A path to a file.</param>        /// <param name="encoding">The encoding of the file at path.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. If you are not interested in possible errors, pass in NULL.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(string contentsOfFile, uint encoding, NSErrorPointer error) { }                /// <summary>        /// Returns a string created by reading data from the file at a given path and returns by reference the encoding used to interpret the file.        /// </summary>        /// <param name="path">A path to a file.</param>        /// <param name="usedEncoding">Upon return, if the file is read successfully, contains the encoding used to interpret the file at path.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, you may pass in NULL.</param>        [iOSVersion(2)]        [Export("stringWithContentsOfFile")]        public static NSString StringWithContentsOfFile(string path, UnsafePointer<uint> usedEncoding, NSErrorPointer error) { return default(NSString); }                /// <summary>        /// Returns an NSString object initialized by reading data from the file at a given path and returns by reference the encoding used to interpret the characters.        /// </summary>        /// <param name="contentsOfFile">A path to a file.</param>        /// <param name="usedEncoding">Upon return, if the file is read successfully, contains the encoding used to interpret the file at path.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, pass in NULL.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(string contentsOfFile, UnsafePointer<uint> usedEncoding, NSErrorPointer error) { }                /// <summary>        /// Returns a string created by reading data from a given URL interpreted using a given encoding.        /// </summary>        /// <param name="url">The URL to read.</param>        /// <param name="encoding">The encoding of the data at url.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, you may pass in NULL.</param>        [iOSVersion(2)]        [Export("stringWithContentsOfURL")]        public static NSString StringWithContentsOfURL(NSURL url, uint encoding, NSErrorPointer error) { return default(NSString); }                /// <summary>        /// Returns an NSString object initialized by reading data from a given URL interpreted using a given encoding.        /// </summary>        /// <param name="contentsOfURL">The URL to read.</param>        /// <param name="encoding">The encoding of the file at path.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, pass in NULL.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(NSURL contentsOfURL, uint encoding, NSErrorPointer error) { }                /// <summary>        /// Returns a string created by reading data from a given URL and returns by reference the encoding used to interpret the data.        /// </summary>        /// <param name="url">The URL from which to read data.</param>        /// <param name="usedEncoding">Upon return, if url is read successfully, contains the encoding used to interpret the data.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, you may pass in NULL.</param>        [iOSVersion(2)]        [Export("stringWithContentsOfURL")]        public static NSString StringWithContentsOfURL(NSURL url, UnsafePointer<uint> usedEncoding, NSErrorPointer error) { return default(NSString); }                /// <summary>        /// Returns an NSString object initialized by reading data from a given URL and returns by reference the encoding used to interpret the data.        /// </summary>        /// <param name="contentsOfURL">The URL from which to read data.</param>        /// <param name="usedEncoding">Upon return, if url is read successfully, contains the encoding used to interpret the data.</param>        /// <param name="error">If an error occurs, upon returns contains an NSError object that describes the problem. If you are not interested in possible errors, pass in NULL.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSString(NSURL contentsOfURL, UnsafePointer<uint> usedEncoding, NSErrorPointer error) { }                /// <summary>        /// Writes the contents of the receiver to a file at a given path using a given encoding.        /// </summary>        /// <param name="path">The file to which to write the receiver. If path contains a tilde (~) character, you must expand it with stringByExpandingTildeInPath before invoking this method.</param>        /// <param name="atomically">If true, the receiver is written to an auxiliary file, and then the auxiliary file is renamed to path. If false, the receiver is written directly to path. The true option guarantees that path, if it exists at all, won’t be corrupted even if the system should crash during writing.</param>        /// <param name="encoding">The encoding to use for the output.</param>        /// <param name="error">If there is an error, upon return contains an NSError object that describes the problem. If you are not interested in details of errors, you may pass in NULL.</param>        [iOSVersion(2)]        [Export("writeToFile")]        public bool WriteToFile(string path, bool atomically, uint encoding, NSErrorPointer error) { return default(bool); }                /// <summary>        /// Writes the contents of the receiver to the URL specified by url using the specified encoding.        /// </summary>        /// <param name="url">The URL to which to write the receiver. Only file URLs are supported.</param>        /// <param name="atomically">If true, the receiver is written to an auxiliary file, and then the auxiliary file is renamed to url. If false, the receiver is written directly to url. The true option guarantees that url, if it exists at all, won’t be corrupted even if the system should crash during writing.        ///   The useAuxiliaryFile parameter is ignored if url is not of a type that can be accessed atomically.</param>        /// <param name="encoding">The encoding to use for the output.</param>        /// <param name="error">If there is an error, upon return contains an NSError object that describes the problem. If you are not interested in details of errors, you may pass in NULL.</param>        [iOSVersion(2)]        [Export("writeToURL")]        public bool WriteToURL(NSURL url, bool atomically, uint encoding, NSErrorPointer error) { return default(bool); }                /// <summary>        /// Returns the number of bytes required to store the receiver in a given encoding.        /// </summary>        /// <param name="enc">The encoding for which to determine the receiver's length.</param>        [iOSVersion(2)]        [Export("lengthOfBytesUsingEncoding")]        public int LengthOfBytesUsingEncoding(uint enc) { return default(int); }                /// <summary>        /// Returns the maximum number of bytes needed to store the receiver in a given encoding.        /// </summary>        /// <param name="enc">The encoding for which to determine the receiver's length.</param>        [iOSVersion(2)]        [Export("maximumLengthOfBytesUsingEncoding")]        public int MaximumLengthOfBytesUsingEncoding(uint enc) { return default(int); }                /// <summary>        /// Returns the character at a given array position.        /// </summary>        /// <param name="index">The index of the character to retrieve. The index value must not lie outside the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("characterAtIndex")]        public unichar CharacterAtIndex(int index) { return default(unichar); }                /// <summary>        /// Copies all characters from the receiver into a given buffer.        /// </summary>        /// <param name="buffer">Upon return, contains the characters from the receiver. buffer must be large enough to contain all characters in the string ([string length]*sizeof(unichar)).</param>        [iOSVersion(2)]        [Export("getCharacters")]        public void GetCharacters(UnsafePointer<unichar> buffer) {  }                /// <summary>        /// Copies characters from a given range in the receiver into a given buffer.        /// </summary>        /// <param name="buffer">Upon return, contains the characters from the receiver. buffer must be large enough to contain the characters in the range aRange (aRange.length*sizeof(unichar)).</param>        /// <param name="range">The range of characters to retrieve. The range must not exceed the bounds of the receiver.        ///     Important        ///     Raises an NSRangeException if any part of aRange lies beyond the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("getCharacters")]        public void GetCharacters(UnsafePointer<unichar> buffer, NSRange range) {  }                /// <summary>        /// Gets a given range of characters as bytes in a specified encoding.        /// </summary>        /// <param name="buffer">A buffer into which to store the bytes from the receiver. The returned bytes are not NULL-terminated.</param>        /// <param name="maxLength">The maximum number of bytes to write to buffer.</param>        /// <param name="usedLength">The number of bytes used from buffer. Pass NULL if you do not need this value.</param>        /// <param name="encoding">The encoding to use for the returned bytes.</param>        /// <param name="options">A mask to specify options to use for converting the receiver’s contents to encoding (if conversion is necessary).</param>        /// <param name="range">The range of characters in the receiver to get.</param>        /// <param name="remainingRange">The remaining range. Pass NULL If you do not need this value.</param>        [iOSVersion(2)]        [Export("getBytes")]        public bool GetBytes(UnsafePointer<Action> buffer, int maxLength, UnsafePointer<int> usedLength, uint encoding, NSStringEncodingConversionOptions options, NSRange range, NSRangePointer remainingRange) { return default(bool); }                /// <summary>        /// Returns a representation of the receiver as a C string using a given encoding.        /// </summary>        /// <param name="encoding">The encoding for the returned C string.</param>        [iOSVersion(2)]        [Export("cStringUsingEncoding")]        public ConstUnsafePointer<Int8> CStringUsingEncoding(uint encoding) { return default(ConstUnsafePointer<Int8>); }                /// <summary>        /// Converts the receiver’s content to a given encoding and stores them in a buffer.        /// </summary>        /// <param name="buffer">Upon return, contains the converted C-string plus the NULL termination byte. The buffer must include room for maxBufferCount bytes.</param>        /// <param name="maxLength">The maximum number of bytes in the string to return in buffer (including the NULL termination byte).</param>        /// <param name="encoding">The encoding for the returned C string.</param>        [iOSVersion(2)]        [Export("getCString")]        public bool GetCString(UnsafePointer<Int8> buffer, int maxLength, uint encoding) { return default(bool); }                /// <summary>        /// Returns a new string made by appending a given string to the receiver.        /// </summary>        /// <param name="aString">The string to append to the receiver. This value must not be nil.        ///     Important        ///     Raises an NSInvalidArgumentException if aString is nil.</param>        [iOSVersion(2)]        [Export("stringByAppendingString")]        public string StringByAppendingString(string aString) { return default(string); }                /// <summary>        /// Returns a new string formed from the receiver by either removing characters from the end, or by appending as many occurrences as necessary of a given pad string.        /// </summary>        /// <param name="newLength">The new length for the receiver.</param>        /// <param name="withString">The string with which to extend the receiver.</param>        /// <param name="startingAtIndex">The index in padString from which to start padding.</param>        [iOSVersion(2)]        [Export("stringByPaddingToLength")]        public string StringByPaddingToLength(int newLength, string withString, int startingAtIndex) { return default(string); }                /// <summary>        /// Returns an array containing substrings from the receiver that have been divided by a given separator.        /// </summary>        /// <param name="separator">The separator string.</param>        [iOSVersion(2)]        [Export("componentsSeparatedByString")]        public AnyObject[] ComponentsSeparatedByString(string separator) { return default(AnyObject[]); }                /// <summary>        /// Returns an array containing substrings from the receiver that have been divided by characters in a given set.        /// </summary>        /// <param name="separator">A character set containing the characters to to use to split the receiver. Must not be nil.</param>        [iOSVersion(2)]        [Export("componentsSeparatedByCharactersInSet")]        public AnyObject[] ComponentsSeparatedByCharactersInSet(NSCharacterSet separator) { return default(AnyObject[]); }                /// <summary>        /// Returns a new string made by removing from both ends of the receiver characters contained in a given character set.        /// </summary>        /// <param name="set">A character set containing the characters to remove from the receiver. set must not be nil.</param>        [iOSVersion(2)]        [Export("stringByTrimmingCharactersInSet")]        public string StringByTrimmingCharactersInSet(NSCharacterSet set) { return default(string); }                /// <summary>        /// Returns a new string containing the characters of the receiver from the one at a given index to the end.        /// </summary>        /// <param name="anIndex">An index. The value must lie within the bounds of the receiver, or be equal to the length of the receiver.        ///   Raises an NSRangeException if (anIndex - 1) lies beyond the end of the receiver.</param>        [iOSVersion(2)]        [Export("substringFromIndex")]        public string SubstringFromIndex(int anIndex) { return default(string); }                /// <summary>        /// Returns a string object containing the characters of the receiver that lie within a given range.        /// </summary>        /// <param name="aRange">A range. The range must not exceed the bounds of the receiver.        ///   Raises an NSRangeException if (aRange.location - 1) or (aRange.location + aRange.length - 1) lies beyond the end of the receiver.</param>        [iOSVersion(2)]        [Export("substringWithRange")]        public string SubstringWithRange(NSRange aRange) { return default(string); }                /// <summary>        /// Returns a new string containing the characters of the receiver up to, but not including, the one at a given index.        /// </summary>        /// <param name="anIndex">An index. The value must lie within the bounds of the receiver, or be equal to the length of the receiver.        ///   Raises an NSRangeException if (anIndex - 1) lies beyond the end of the receiver.</param>        [iOSVersion(2)]        [Export("substringToIndex")]        public string SubstringToIndex(int anIndex) { return default(string); }                /// <summary>        /// Finds and returns the range in the receiver of the first character from a given character set.        /// </summary>        /// <param name="aSet">A character set. This value must not be nil.        ///   Raises an NSInvalidArgumentException if aSet is nil.</param>        [iOSVersion(2)]        [Export("rangeOfCharacterFromSet")]        public NSRange RangeOfCharacterFromSet(NSCharacterSet aSet) { return default(NSRange); }                /// <summary>        /// Finds and returns the range in the receiver of the first character, using given options, from a given character set.        /// </summary>        /// <param name="aSet">A character set. This value must not be nil.        ///   Raises an NSInvalidArgumentException if aSet is nil.</param>        /// <param name="options">A mask specifying search options. The following options may be specified by combining them with the C bitwise OR operator: NSAnchoredSearch, NSBackwardsSearch.</param>        [iOSVersion(2)]        [Export("rangeOfCharacterFromSet")]        public NSRange RangeOfCharacterFromSet(NSCharacterSet aSet, NSStringCompareOptions options) { return default(NSRange); }                /// <summary>        /// Finds and returns the range in the receiver of the first character from a given character set found in a given range with given options.        /// </summary>        /// <param name="aSet">A character set. This value must not be nil.        ///   Raises an NSInvalidArgumentException if aSet is nil.</param>        /// <param name="options">A mask specifying search options. The following options may be specified by combining them with the C bitwise OR operator: NSAnchoredSearch, NSBackwardsSearch.</param>        /// <param name="range">The range in which to search. aRange must not exceed the bounds of the receiver.        ///   Raises an NSRangeException if aRange is invalid.</param>        [iOSVersion(2)]        [Export("rangeOfCharacterFromSet")]        public NSRange RangeOfCharacterFromSet(NSCharacterSet aSet, NSStringCompareOptions options, NSRange range) { return default(NSRange); }                /// <summary>        /// Finds and returns the range of the first occurrence of a given string within the receiver.        /// </summary>        /// <param name="aString">The string to search for. This value must not be nil.        ///   Raises an NSInvalidArgumentException if aString is nil.</param>        [iOSVersion(2)]        [Export("rangeOfString")]        public NSRange RangeOfString(string aString) { return default(NSRange); }                /// <summary>        /// Finds and returns the range of the first occurrence of a given string within the receiver, subject to given options.        /// </summary>        /// <param name="aString">The string to search for. This value must not be nil.        ///     Important        ///     Raises an NSInvalidArgumentException if aString is nil.</param>        /// <param name="options">A mask specifying search options. The following options may be specified by combining them with the C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch, NSBackwardsSearch, NSAnchoredSearch. See String Programming Guide for details on these options.</param>        [iOSVersion(2)]        [Export("rangeOfString")]        public NSRange RangeOfString(string aString, NSStringCompareOptions options) { return default(NSRange); }                /// <summary>        /// Finds and returns the range of the first occurrence of a given string, within the given range of the receiver, subject to given options.        /// </summary>        /// <param name="aString">The string for which to search. This value must not be nil.        ///   Raises an NSInvalidArgumentException if aString is nil.</param>        /// <param name="options">A mask specifying search options. The following options may be specified by combining them with the C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch, NSBackwardsSearch, and NSAnchoredSearch. See String Programming Guide for details on these options.</param>        /// <param name="range">The range within the receiver for which to search for aString.        ///   Raises an NSRangeException if aRange is invalid.</param>        [iOSVersion(2)]        [Export("rangeOfString")]        public NSRange RangeOfString(string aString, NSStringCompareOptions options, NSRange range) { return default(NSRange); }                /// <summary>        /// Finds and returns the range of the first occurrence of a given string within a given range of the receiver, subject to given options, using the specified locale, if any.        /// </summary>        /// <param name="aString">The string for which to search. This value must not be nil.        ///   Raises an NSInvalidArgumentException if aString is nil.</param>        /// <param name="options">A mask specifying search options. The following options may be specified by combining them with the C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch, NSBackwardsSearch, and NSAnchoredSearch. See String Programming Guide for details on these options.</param>        /// <param name="range">The range within the receiver for which to search for aString.        ///   Raises an NSRangeException if aRange is invalid.</param>        /// <param name="locale">The locale to use when comparing the receiver with aString. To use the current locale, pass [NSLocalecurrentLocale]. To use the system locale, pass nil.        ///   The locale argument affects the equality checking algorithm. For example, for the Turkish locale, case-insensitive compare matches “I” to “ı” (Unicode code point U+0131, Latin Small Dotless I), not the normal “i” character.</param>        [iOSVersion(2)]        [Export("rangeOfString")]        public NSRange RangeOfString(string aString, NSStringCompareOptions options, NSRange range, NSLocale locale) { return default(NSRange); }                /// <summary>        /// Enumerates all the lines in a string.        /// </summary>        /// <param name="block">The block executed for the enumeration.        ///   The block takes two arguments:        ///       line        ///   The current line of the string being enumerated. The line contains just the contents of the line, without the line terminators. See getLineStart:end:contentsEnd:forRange: for a discussion of line terminators.        ///       stop        ///   A reference to a Boolean value that the block can use to stop the enumeration by setting *stop = YES; it should not touch *stop otherwise.</param>        [iOSVersion(4)]        [Export("enumerateLinesUsingBlock")]        public void EnumerateLinesUsingBlock(Action<string, UnsafePointer<ObjCBool>> block) {  }                /// <summary>        /// Enumerates the substrings of the specified type in the specified range of the string.        /// </summary>        /// <param name="range">The range within the string to enumerate substrings.</param>        /// <param name="options">Options specifying types of substrings and enumeration styles.</param>        /// <param name="usingBlock">The block executed for the enumeration.        ///   The block takes four arguments:        ///       substring        ///   The enumerated string.        ///       substringRange        ///   The range of the enumerated string in the receiver.        ///       enclosingRange        ///   The range that includes the substring as well as any separator or filler characters that follow. For instance, for lines, enclosingRange contains the line terminators. The enclosingRange for the first string enumerated also contains any characters that occur before the string. Consecutive enclosing ranges are guaranteed not to overlap, and every single character in the enumerated range is included in one and only one enclosing range.        ///       stop        ///   A reference to a Boolean value that the block can use to stop the enumeration by setting *stop = YES; it should not touch *stop otherwise.</param>        [iOSVersion(4)]        [Export("enumerateSubstringsInRange")]        public void EnumerateSubstringsInRange(NSRange range, NSStringEnumerationOptions options, Action<string, NSRange, NSRange, UnsafePointer<ObjCBool>> usingBlock) {  }                /// <summary>        /// Returns a new string in which all occurrences of a target string in the receiver are replaced by another given string.        /// </summary>        /// <param name="target">The string to replace.</param>        /// <param name="withString">The string with which to replace target.</param>        [iOSVersion(2)]        [Export("stringByReplacingOccurrencesOfString")]        public string StringByReplacingOccurrencesOfString(string target, string withString) { return default(string); }                /// <summary>        /// Returns a new string in which all occurrences of a target string in a specified range of the receiver are replaced by another given string.        /// </summary>        /// <param name="target">The string to replace.</param>        /// <param name="withString">The string with which to replace target.</param>        /// <param name="options">A mask of options to use when comparing target with the receiver. Pass 0 to specify no options.</param>        /// <param name="range">The range in the receiver in which to search for target.</param>        [iOSVersion(2)]        [Export("stringByReplacingOccurrencesOfString")]        public string StringByReplacingOccurrencesOfString(string target, string withString, NSStringCompareOptions options, NSRange range) { return default(string); }                /// <summary>        /// Returns a new string in which the characters in a specified range of the receiver are replaced by a given string.        /// </summary>        /// <param name="range">A range of characters in the receiver.</param>        /// <param name="withString">The string with which to replace the characters in range.</param>        [iOSVersion(2)]        [Export("stringByReplacingCharactersInRange")]        public string StringByReplacingCharactersInRange(NSRange range, string withString) { return default(string); }                /// <summary>        /// Returns by reference the beginning of the first line and the end of the last line touched by the given range.        /// </summary>        /// <param name="startIndex">Upon return, contains the index of the first character of the line containing the beginning of aRange. Pass NULL if you do not need this value (in which case the work to compute the value isn’t performed).</param>        /// <param name="end">Upon return, contains the index of the first character past the terminator of the line containing the end of aRange. Pass NULL if you do not need this value (in which case the work to compute the value isn’t performed).</param>        /// <param name="contentsEnd">Upon return, contains the index of the first character of the terminator of the line containing the end of aRange. Pass NULL if you do not need this value (in which case the work to compute the value isn’t performed).</param>        /// <param name="forRange">A range within the receiver. The value must not exceed the bounds of the receiver.         ///   Raises an NSRangeException if aRange is invalid.</param>        [iOSVersion(2)]        [Export("getLineStart")]        public void GetLineStart(UnsafePointer<int> startIndex, UnsafePointer<int> end, UnsafePointer<int> contentsEnd, NSRange forRange) {  }                /// <summary>        /// Returns the range of characters representing the line or lines containing a given range.        /// </summary>        /// <param name="aRange">A range within the receiver. The value must not exceed the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("lineRangeForRange")]        public NSRange LineRangeForRange(NSRange aRange) { return default(NSRange); }                /// <summary>        /// Returns by reference the beginning of the first paragraph and the end of the last paragraph touched by the given range.        /// </summary>        /// <param name="startIndex">Upon return, contains the index of the first character of the paragraph containing the beginning of aRange. Pass NULL if you do not need this value (in which case the work to compute the value isn’t performed).</param>        /// <param name="end">Upon return, contains the index of the first character past the terminator of the paragraph containing the end of aRange. Pass NULL if you do not need this value (in which case the work to compute the value isn’t performed).</param>        /// <param name="contentsEnd">Upon return, contains the index of the first character of the terminator of the paragraph containing the end of aRange. Pass NULL if you do not need this value (in which case the work to compute the value isn’t performed).</param>        /// <param name="forRange">A range within the receiver. The value must not exceed the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("getParagraphStart")]        public void GetParagraphStart(UnsafePointer<int> startIndex, UnsafePointer<int> end, UnsafePointer<int> contentsEnd, NSRange forRange) {  }                /// <summary>        /// Returns the range of characters representing the paragraph or paragraphs containing a given range.        /// </summary>        /// <param name="aRange">A range within the receiver. The range must not exceed the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("paragraphRangeForRange")]        public NSRange ParagraphRangeForRange(NSRange aRange) { return default(NSRange); }                /// <summary>        /// Returns the range in the receiver of the composed character sequence located at a given index.        /// </summary>        /// <param name="anIndex">The index of a character in the receiver. The value must not exceed the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("rangeOfComposedCharacterSequenceAtIndex")]        public NSRange RangeOfComposedCharacterSequenceAtIndex(int anIndex) { return default(NSRange); }                /// <summary>        /// Returns the range in the string of the composed character sequences for a given range.        /// </summary>        /// <param name="range">A range in the receiver. The range must not exceed the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("rangeOfComposedCharacterSequencesForRange")]        public NSRange RangeOfComposedCharacterSequencesForRange(NSRange range) { return default(NSRange); }                /// <summary>        /// Parses the receiver as a text representation of a property list, returning an NSString, NSData, NSArray, or NSDictionary object, according to the topmost element.        /// </summary>        [iOSVersion(2)]        [Export("propertyList")]        public AnyObject PropertyList() { return default(AnyObject); }                /// <summary>        /// Returns a dictionary object initialized with the keys and values found in the receiver.        /// </summary>        [iOSVersion(2)]        [Export("propertyListFromStringsFileFormat")]        public Dictionary<NSObject, AnyObject> PropertyListFromStringsFileFormat() { return default(Dictionary<NSObject, AnyObject>); }                /// <summary>        /// Returns the result of invoking compare:options: with NSCaseInsensitiveSearch as the only option.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.         ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        [iOSVersion(2)]        [Export("caseInsensitiveCompare")]        public NSComparisonResult CaseInsensitiveCompare(string aString) { return default(NSComparisonResult); }                /// <summary>        /// Compares the string with a given string using a case-insensitive, localized, comparison.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.        ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        [iOSVersion(2)]        [Export("localizedCaseInsensitiveCompare")]        public NSComparisonResult LocalizedCaseInsensitiveCompare(string aString) { return default(NSComparisonResult); }                /// <summary>        /// Returns the result of invoking compare:options:range: with no options and the receiver’s full extent as the range.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.        ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        [iOSVersion(2)]        [Export("compare")]        public NSComparisonResult Compare(string aString) { return default(NSComparisonResult); }                /// <summary>        /// Compares the string and a given string using a localized comparison.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.        ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        [iOSVersion(2)]        [Export("localizedCompare")]        public NSComparisonResult LocalizedCompare(string aString) { return default(NSComparisonResult); }                /// <summary>        /// Compares the string with the specified string using the given options.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.         ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        /// <param name="options">Options for the search—you can combine any of the following using a C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch, NSNumericSearch. See String Programming Guide for details on these options.</param>        [iOSVersion(2)]        [Export("compare")]        public NSComparisonResult Compare(string aString, NSStringCompareOptions options) { return default(NSComparisonResult); }                /// <summary>        /// Returns the result of invoking compare:options:range:locale: with a nil locale.        /// </summary>        /// <param name="aString">The string with which to compare the range of the receiver specified by range.         ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        /// <param name="options">Options for the search—you can combine any of the following using a C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch, NSNumericSearch.        ///   See String Programming Guide for details on these options.</param>        /// <param name="range">The range of the receiver over which to perform the comparison. The range must not exceed the bounds of the receiver.        ///     Important        ///     Raises an NSRangeException if range exceeds the bounds of the receiver.</param>        [iOSVersion(2)]        [Export("compare")]        public NSComparisonResult Compare(string aString, NSStringCompareOptions options, NSRange range) { return default(NSComparisonResult); }                /// <summary>        /// Compares the string using the specified options and returns the lexical ordering for the range.        /// </summary>        /// <param name="aString">The string with which to compare the range of the receiver specified by range.         ///   This value must not be nil. If this value is nil, the behavior is undefined and may change in future versions of OS X.</param>        /// <param name="options">Options for the search—you can combine any of the following using a C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch, NSNumericSearch.        ///   See String Programming Guide for details on these options.</param>        /// <param name="range">The range of the receiver over which to perform the comparison. The range must not exceed the bounds of the receiver.        ///     Important        ///     Raises an NSRangeException if range exceeds the bounds of the receiver.</param>        /// <param name="locale">An instance of NSLocale. To use the current locale, pass [NSLocale currentLocale]. For example, if you are comparing strings to present to the end-user, use the current locale. To use the system locale, pass nil.</param>        [iOSVersion(2)]        [Export("compare")]        public NSComparisonResult Compare(string aString, NSStringCompareOptions options, NSRange range, AnyObject locale) { return default(NSComparisonResult); }                /// <summary>        /// Compares strings as sorted by the Finder.        /// </summary>        /// <param name="@string">The string to compare with the receiver.</param>        [iOSVersion(4)]        [Export("localizedStandardCompare")]        public NSComparisonResult LocalizedStandardCompare(string @string) { return default(NSComparisonResult); }                /// <summary>        /// Returns a Boolean value that indicates whether a given string matches the beginning characters of the receiver.        /// </summary>        /// <param name="aString">A string.</param>        [iOSVersion(2)]        [Export("hasPrefix")]        public bool HasPrefix(string aString) { return default(bool); }                /// <summary>        /// Returns a Boolean value that indicates whether a given string matches the ending characters of the receiver.        /// </summary>        /// <param name="aString">A string.</param>        [iOSVersion(2)]        [Export("hasSuffix")]        public bool HasSuffix(string aString) { return default(bool); }                /// <summary>        /// Returns a Boolean value that indicates whether a given string is equal to the receiver using a literal Unicode-based comparison.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.</param>        [iOSVersion(2)]        [Export("isEqualToString")]        public bool IsEqualToString(string aString) { return default(bool); }                /// <summary>        /// Returns a string with the given character folding options applied.        /// </summary>        /// <param name="options">A mask of compare flags with a suffix InsensitiveSearch.</param>        /// <param name="locale">The locale to use for the folding. To use the current locale, pass [NSLocalecurrentLocale]. To use the system locale, pass nil.</param>        [iOSVersion(2)]        [Export("stringByFoldingWithOptions")]        public string StringByFoldingWithOptions(NSStringCompareOptions options, NSLocale locale) { return default(string); }                /// <summary>        /// Returns a string containing characters the receiver and a given string have in common, starting from the beginning of each up to the first characters that aren’t equivalent.        /// </summary>        /// <param name="aString">The string with which to compare the receiver.</param>        /// <param name="options">Options for the comparison. The following search options may be specified by combining them with the C bitwise OR operator: NSCaseInsensitiveSearch, NSLiteralSearch. See String Programming Guide for details on these options.</param>        [iOSVersion(2)]        [Export("commonPrefixWithString")]        public string CommonPrefixWithString(string aString, NSStringCompareOptions options) { return default(string); }                /// <summary>        /// Returns a capitalized representation of the receiver using the specified locale.        /// </summary>        /// <param name="locale">The locale. For strings presented to users, pass the current locale ([NSLocalecurrentLocale]). To use the system locale, pass nil.</param>        [iOSVersion(6)]        [Export("capitalizedStringWithLocale")]        public string CapitalizedStringWithLocale(NSLocale locale) { return default(string); }                /// <summary>        /// Returns a version of the string with all letters converted to lowercase, taking into account the specified locale.        /// </summary>        /// <param name="locale">The locale. For strings presented to users, pass the current locale ([NSLocalecurrentLocale]). To use the system local, pass nil.</param>        [iOSVersion(6)]        [Export("lowercaseStringWithLocale")]        public string LowercaseStringWithLocale(NSLocale locale) { return default(string); }                /// <summary>        /// Returns a version of the string with all letters converted to uppercase, taking into account the specified locale.        /// </summary>        /// <param name="locale">The locale. For strings presented to users, pass the current locale ([NSLocalecurrentLocale]). To use the system locale, pass nil.</param>        [iOSVersion(6)]        [Export("uppercaseStringWithLocale")]        public string UppercaseStringWithLocale(NSLocale locale) { return default(string); }                /// <summary>        /// Returns a zero-terminated list of the encodings string objects support in the application’s environment.        /// </summary>        [iOSVersion(2)]        [Export("availableStringEncodings")]        public static ConstUnsafePointer<uint> AvailableStringEncodings() { return default(ConstUnsafePointer<uint>); }                /// <summary>        /// Returns the C-string encoding assumed for any method accepting a C string as an argument.        /// </summary>        [iOSVersion(2)]        [Export("defaultCStringEncoding")]        public static uint DefaultCStringEncoding() { return default(uint); }                /// <summary>        /// Returns a human-readable string giving the name of a given encoding.        /// </summary>        /// <param name="encoding">A string encoding.</param>        [iOSVersion(2)]        [Export("localizedNameOfStringEncoding")]        public static string LocalizedNameOfStringEncoding(uint encoding) { return default(string); }                /// <summary>        /// Returns a Boolean value that indicates whether the receiver can be converted to a given encoding without loss of information.        /// </summary>        /// <param name="encoding">A string encoding.</param>        [iOSVersion(2)]        [Export("canBeConvertedToEncoding")]        public bool CanBeConvertedToEncoding(uint encoding) { return default(bool); }                /// <summary>        /// Returns an NSData object containing a representation of the receiver encoded using a given encoding.        /// </summary>        /// <param name="encoding">A string encoding.</param>        [iOSVersion(2)]        [Export("dataUsingEncoding")]        public NSData DataUsingEncoding(uint encoding) { return default(NSData); }                /// <summary>        /// Returns an NSData object containing a representation of the receiver encoded using a given encoding.        /// </summary>        /// <param name="encoding">A string encoding.</param>        /// <param name="allowLossyConversion">If true, then allows characters to be removed or altered in conversion.</param>        [iOSVersion(2)]        [Export("dataUsingEncoding")]        public NSData DataUsingEncoding(uint encoding, bool allowLossyConversion) { return default(NSData); }                /// <summary>        /// Returns a string built from the strings in a given array by concatenating them with a path separator between each pair.        /// </summary>        /// <param name="components">An array of NSString objects representing a file path. To create an absolute path, use a slash mark (“/”) as the first component. To include a trailing path divider, use an empty string as the last component.</param>        [iOSVersion(2)]        [Export("pathWithComponents")]        public static string PathWithComponents(AnyObject[] components) { return default(string); }                /// <summary>        /// Interprets the receiver as a path in the file system and attempts to perform filename completion, returning a numeric value that indicates whether a match was possible, and by reference the longest path that matches the receiver.        /// </summary>        /// <param name="outputName">Upon return, contains the longest path that matches the receiver.</param>        /// <param name="caseSensitive">If true, the method considers case for possible completions.</param>        /// <param name="matchesIntoArray">Upon return, contains all matching filenames.</param>        /// <param name="filterTypes">An array of NSString objects specifying path extensions to consider for completion. Only paths whose extensions (not including the extension separator) match one of these strings are included in outputArray. Pass nil if you don’t want to filter the output.</param>        [iOSVersion(2)]        [Export("completePathIntoString")]        public int CompletePathIntoString(AutoreleasingUnsafePointer<string> outputName, bool caseSensitive, AutoreleasingUnsafePointer<NSArray> matchesIntoArray, AnyObject[] filterTypes) { return default(int); }                /// <summary>        /// Interprets the receiver as a system-independent path and fills a buffer with a C-string in a format and encoding suitable for use with file-system calls.        /// </summary>        /// <param name="buffer">Upon return, contains a C-string that represent the receiver as as a system-independent path, plus the NULL termination byte. The size of buffer must be large enough to contain maxLength bytes.</param>        /// <param name="maxLength">The maximum number of bytes in the string to return in buffer (including a terminating NULL character, which this method adds).</param>        [iOSVersion(2)]        [Export("getFileSystemRepresentation")]        public bool GetFileSystemRepresentation(UnsafePointer<Int8> buffer, int maxLength) { return default(bool); }                /// <summary>        /// Returns a new string made by appending to the receiver a given string.        /// </summary>        /// <param name="aString">The path component to append to the receiver.</param>        [iOSVersion(2)]        [Export("stringByAppendingPathComponent")]        public string StringByAppendingPathComponent(string aString) { return default(string); }                /// <summary>        /// Returns a new string made by appending to the receiver an extension separator followed by a given extension.        /// </summary>        /// <param name="ext">The extension to append to the receiver.</param>        [iOSVersion(2)]        [Export("stringByAppendingPathExtension")]        public string StringByAppendingPathExtension(string ext) { return default(string); }                /// <summary>        /// Returns an array of strings made by separately appending to the receiver each string in in a given array.        /// </summary>        /// <param name="paths">An array of NSString objects specifying paths to add to the receiver.</param>        [iOSVersion(2)]        [Export("stringsByAppendingPaths")]        public AnyObject[] StringsByAppendingPaths(AnyObject[] paths) { return default(AnyObject[]); }                /// <summary>        /// Returns a representation of the receiver using a given encoding to determine the percent escapes necessary to convert the receiver into a legal URL string.        /// </summary>        /// <param name="encoding">The encoding to use for the returned string. If you are uncertain of the correct encoding you should use NSUTF8StringEncoding.</param>        [iOSVersion(2)]        [Export("stringByAddingPercentEscapesUsingEncoding")]        public string StringByAddingPercentEscapesUsingEncoding(uint encoding) { return default(string); }                /// <summary>        /// Returns a new string made by replacing in the receiver all percent escapes with the matching characters as determined by a given encoding.        /// </summary>        /// <param name="encoding">The encoding to use for the returned string.</param>        [iOSVersion(2)]        [Export("stringByReplacingPercentEscapesUsingEncoding")]        public string StringByReplacingPercentEscapesUsingEncoding(uint encoding) { return default(string); }                /// <summary>        /// Returns a new string made from the receiver by replacing all characters not in the specified set with percent encoded characters.        /// </summary>        /// <param name="allowedCharacters">The characters not replaced in the string.</param>        [iOSVersion(7)]        [Export("stringByAddingPercentEncodingWithAllowedCharacters")]        public string StringByAddingPercentEncodingWithAllowedCharacters(NSCharacterSet allowedCharacters) { return default(string); }                /// <summary>        /// Performs linguistic analysis on the specified string by enumerating the specific range of the string, providing the Block with the located tags.        /// </summary>        /// <param name="range">The range of the string to analyze.</param>        /// <param name="scheme">The tag scheme to use. See Linguistic Tag Schemes for supported values.</param>        /// <param name="options">The linguistic tagger options to use. See NSLinguisticTaggerOptionsfor the constants. These constants can be combined using the C-Bitwise OR operator.</param>        /// <param name="orthography">The orthography of the string. If nil, the linguistic tagger will attempt to determine the orthography from the string content.</param>        /// <param name="usingBlock">The Block to apply to the string.        ///   The block takes four arguments:        ///       tag        ///   The tag scheme for the token. The opts parameter specifies the types of tagger options that are located.        ///       tokenRange        ///   The range of a string matching the tag scheme.        ///       sentenceRange        ///   The range of the sentence in which the token is found.        ///       stop        ///   A reference to a Boolean value. The block can set the value to true to stop further processing of the array. The stop argument is an out-only argument. You should only ever set this Boolean to true within the Block.</param>        [iOSVersion(5)]        [Export("enumerateLinguisticTagsInRange")]        public void EnumerateLinguisticTagsInRange(NSRange range, string scheme, NSLinguisticTaggerOptions options, NSOrthography orthography, Action<string, NSRange, NSRange, UnsafePointer<ObjCBool>> usingBlock) {  }                /// <summary>        /// Returns an array of linguistic tags for the specified range and requested tags within the receiving string.        /// </summary>        /// <param name="range">The range of the string to analyze.</param>        /// <param name="scheme">The tag scheme to use. See Linguistic Tag Schemes for supported values.</param>        /// <param name="options">The linguistic tagger options to use. See NSLinguisticTaggerOptions for the constants. These constants can be combined using the C-Bitwise OR operator.</param>        /// <param name="orthography">The orthography of the string. If nil, the linguistic tagger will attempt to determine the orthography from the string content.</param>        /// <param name="tokenRanges">An array returned by-reference containing the token ranges of the linguistic tags wrapped in NSValue objects.</param>        [iOSVersion(5)]        [Export("linguisticTagsInRange")]        public AnyObject[] LinguisticTagsInRange(NSRange range, string scheme, NSLinguisticTaggerOptions options, NSOrthography orthography, AutoreleasingUnsafePointer<NSArray> tokenRanges) { return default(AnyObject[]); }                /// <summary>        /// The number of Unicode characters in the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("length")]        public int Length { get; private set; }                /// <summary>        /// A null-terminated UTF8 representation of the string. (read-only)        /// </summary>        [iOSVersion(2)]        public ConstUnsafePointer<Int8> UTF8String { get; private set; }                /// <summary>        /// An unsigned integer that can be used as a hash table address. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("hash")]        public int Hash { get; private set; }                /// <summary>        /// A capitalized representation of the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("capitalizedString")]        public string CapitalizedString { get; private set; }                /// <summary>        /// A lowercase representation of the string.        /// </summary>        [iOSVersion(2)]        [Export("lowercaseString")]        public string LowercaseString { get; private set; }                /// <summary>        /// An uppercase representation of the string. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("uppercaseString")]        public string UppercaseString { get; private set; }                /// <summary>        /// A string made by normalizing the string’s contents using the Unicode Normalization Form D. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("decomposedStringWithCanonicalMapping")]        public string DecomposedStringWithCanonicalMapping { get; private set; }                /// <summary>        /// A string made by normalizing the receiver’s contents using the Unicode Normalization Form KD. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("decomposedStringWithCompatibilityMapping")]        public string DecomposedStringWithCompatibilityMapping { get; private set; }                /// <summary>        /// A string made by normalizing the string’s contents using the Unicode Normalization Form C. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("precomposedStringWithCanonicalMapping")]        public string PrecomposedStringWithCanonicalMapping { get; private set; }                /// <summary>        /// A string made by normalizing the receiver’s contents using the Unicode Normalization Form KC. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("precomposedStringWithCompatibilityMapping")]        public string PrecomposedStringWithCompatibilityMapping { get; private set; }                /// <summary>        /// The floating-point value of the string as a double. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("doubleValue")]        public Double DoubleValue { get; private set; }                /// <summary>        /// The floating-point value of the string as a float. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("floatValue")]        public float FloatValue { get; private set; }                /// <summary>        /// The integer value of the string. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("intValue")]        public int IntValue { get; private set; }                /// <summary>        /// The NSInteger value of the string. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("integerValue")]        public int IntegerValue { get; private set; }                /// <summary>        /// The long long value of the string. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("longLongValue")]        public Int64 LongLongValue { get; private set; }                /// <summary>        /// The Boolean value of the string. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("boolValue")]        public bool BoolValue { get; private set; }                /// <summary>        /// This NSString object. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("description")]        public string Description { get; private set; }                /// <summary>        /// The fastest encoding to which the receiver may be converted without loss of information. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("fastestEncoding")]        public uint FastestEncoding { get; private set; }                /// <summary>        /// The smallest encoding to which the receiver can be converted without loss of information. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("smallestEncoding")]        public uint SmallestEncoding { get; private set; }                /// <summary>        /// Returns an array of NSString objects containing, in order, each path component of the receiver.        /// </summary>        [iOSVersion(2)]        [Export("pathComponents")]        public AnyObject[] PathComponents { get; private set; }                /// <summary>        /// Returns a file system-specific representation of the receiver.        /// </summary>        [iOSVersion(2)]        [Export("fileSystemRepresentation")]        public ConstUnsafePointer<Int8> FileSystemRepresentation { get; private set; }                /// <summary>        /// Returns the last path component of the receiver.        /// </summary>        [iOSVersion(2)]        [Export("lastPathComponent")]        public string LastPathComponent { get; private set; }                /// <summary>        /// Interprets the receiver as a path and returns the receiver’s extension, if any.        /// </summary>        [iOSVersion(2)]        [Export("pathExtension")]        public string PathExtension { get; private set; }                /// <summary>        /// Returns a new string that replaces the current home directory portion of the current path with a tilde (~) character.        /// </summary>        [iOSVersion(2)]        [Export("stringByAbbreviatingWithTildeInPath")]        public string StringByAbbreviatingWithTildeInPath { get; private set; }                /// <summary>        /// Returns a new string made by deleting the last path component from the receiver, along with any final path separator.        /// </summary>        [iOSVersion(2)]        [Export("stringByDeletingLastPathComponent")]        public string StringByDeletingLastPathComponent { get; private set; }                /// <summary>        /// Returns a new string made by deleting the extension (if any, and only the last) from the receiver.        /// </summary>        [iOSVersion(2)]        [Export("stringByDeletingPathExtension")]        public string StringByDeletingPathExtension { get; private set; }                /// <summary>        /// Returns a new string made by expanding the initial component of the receiver to its full path value.        /// </summary>        [iOSVersion(2)]        [Export("stringByExpandingTildeInPath")]        public string StringByExpandingTildeInPath { get; private set; }                /// <summary>        /// Returns a new string made from the receiver by resolving all symbolic links and standardizing path.        /// </summary>        [iOSVersion(2)]        [Export("stringByResolvingSymlinksInPath")]        public string StringByResolvingSymlinksInPath { get; private set; }                /// <summary>        /// Returns a new string made by removing extraneous path components from the receiver.        /// </summary>        [iOSVersion(2)]        [Export("stringByStandardizingPath")]        public string StringByStandardizingPath { get; private set; }                /// <summary>        /// Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.        /// </summary>        [iOSVersion(7)]        [Export("stringByRemovingPercentEncoding")]        public string StringByRemovingPercentEncoding { get; private set; }                /// <summary>        /// The following constants are provided by NSString as possible string encodings.        /// </summary>        public int NSProprietaryStringEncoding { get; set; }    }    /// <summary>    /// Type for encoding conversion options.    /// </summary>    [iOSVersion(2)]    public enum NSStringEncodingConversionOptions    {        /// <summary>        ///         /// </summary>        AllowLossy,        /// <summary>        ///         /// </summary>        ExternalRepresentation,    }    /// <summary>    /// These values represent the options available to many of the string classes’ search and comparison methods.    /// </summary>    public enum NSStringCompareOptions    {        /// <summary>        /// A case-insensitive search.        /// </summary>        [iOSVersion(2)]        CaseInsensitiveSearch,        /// <summary>        /// Exact character-by-character equivalence.        /// </summary>        [iOSVersion(2)]        LiteralSearch,        /// <summary>        /// Search from end of source string.        /// </summary>        [iOSVersion(2)]        BackwardsSearch,        /// <summary>        /// Search is limited to start (or end, if NSBackwardsSearch) of source string.        /// </summary>        [iOSVersion(2)]        AnchoredSearch,        /// <summary>        /// Numbers within strings are compared using numeric value, that is, Name2.txt < Name7.txt < Name25.txt.        /// Numeric comparison only applies to the numerals in the string, not other characters that would have meaning in a true number such as a negative sign or a decimal point.        /// This option only applies to compare methods, not find.        /// </summary>        [iOSVersion(2)]        NumericSearch,        /// <summary>        /// Search ignores diacritic marks.        /// For example, ‘ö’ is equal to ‘o’.        /// </summary>        [iOSVersion(2)]        DiacriticInsensitiveSearch,        /// <summary>        /// Search ignores width differences in characters that have full-width and half-width forms, as occurs in East Asian character sets.        /// For example, with this option, the full-width Latin small letter 'a' (Unicode code point U+FF41) is equal to the basic Latin small letter 'a' (Unicode code point U+0061).        /// </summary>        [iOSVersion(2)]        WidthInsensitiveSearch,        /// <summary>        /// Comparisons are forced to return either NSOrderedAscending or NSOrderedDescending if the strings are equivalent but not strictly equal.        /// This option ensures reliable, reproducible results when sorting. For example, “aaa” is greater than &quot;AAA”  if NSCaseInsensitiveSearch is specified.        /// </summary>        [iOSVersion(2)]        ForcedOrderingSearch,        /// <summary>        /// The search string is treated as an ICU-compatible regular expression. If set, no other options can apply except NSCaseInsensitiveSearch and NSAnchoredSearch. You can use this option only with the rangeOfString:... methods and stringByReplacingOccurrencesOfString:withString:options:range:.        /// </summary>        [iOSVersion(3.2)]        RegularExpressionSearch,    }    /// <summary>    /// Constants to specify kinds of substrings and styles of enumeration.    /// </summary>    [iOSVersion(4)]    public enum NSStringEnumerationOptions    {        /// <summary>        /// Enumerates by lines. Equivalent to lineRangeForRange:.        /// </summary>        [iOSVersion(4)]        ByLines,        /// <summary>        /// Enumerates by paragraphs. Equivalent to paragraphRangeForRange:.        /// </summary>        [iOSVersion(4)]        ByParagraphs,        /// <summary>        /// Enumerates by composed character sequences. Equivalent to rangeOfComposedCharacterSequencesForRange:.        /// </summary>        [iOSVersion(4)]        ByComposedCharacterSequences,        /// <summary>        /// Enumerates by words.        /// </summary>        [iOSVersion(4)]        ByWords,        /// <summary>        /// Enumerates by sentences.        /// </summary>        [iOSVersion(4)]        BySentences,        /// <summary>        /// Causes enumeration to occur from the end of the specified range to the start.        /// </summary>        [iOSVersion(4)]        Reverse,        /// <summary>        /// A way to indicate that the block does not need substring, in which case nil will be passed. This is simply a performance shortcut.        /// </summary>        [iOSVersion(4)]        SubstringNotRequired,        /// <summary>        /// Causes the enumeration to occur using the current locale. This does not make a difference in line, paragraph, or composed character sequence enumeration, but it may for words or sentences.        /// </summary>        [iOSVersion(4)]        Localized,    }    /// <summary>    /// Type for Unicode characters.    /// </summary>    [iOSVersion(2)]    [Export("unichar")]    public struct Unichar    {        static public implicit operator Unichar(UInt16 value)        {            return default(Unichar);        }        static public implicit operator UInt16(Unichar value)        {            return default(UInt16);        }    }}
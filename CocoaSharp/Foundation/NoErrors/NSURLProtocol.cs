using ObjectiveC;using System;using SwiftSharp.Attributes;namespace Foundation{	//https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLProtocol_Class/index.html#//apple_ref/occ/cl/NSURLProtocol	/// <summary>	/// NSURLProtocol is an abstract class that provides the basic structure for performing protocol-specific loading of URL data. Concrete subclasses handle the specifics associated with one or more protocols or URL schemes.	/// </summary>	[iOSVersion(2)]	public class NSURLProtocol : NSObject	{		/// <summary>		/// Initializes an NSURLProtocol object.		/// </summary>		/// <param name="request">The URL request for the URL protocol object. This request is retained.</param>		/// <param name="cachedResponse">A cached response for the request; may be nil if there is no existing cached response for the request.</param>		/// <param name="client">An object that provides an implementation of the NSURLProtocolClient protocol that the receiver uses to communicate with the URL loading system. This client object is retained.</param>		[iOSVersion(2)]		public NSURLProtocol(NSURLRequest request, NSCachedURLResponse cachedResponse, NSURLProtocolClient client) { }				/// <summary>		/// Attempts to register a subclass of NSURLProtocol, making it visible to the URL loading system.		/// </summary>		/// <param name="protocolClass">The subclass of NSURLProtocol to register.</param>		/// <returns>true if the registration is successful, false otherwise. The only failure condition is if protocolClass is not a subclass of NSURLProtocol.</returns>		[iOSVersion(2)]		[Export("registerClass")]		public static bool RegisterClass(AnyClass protocolClass) { return false; }				/// <summary>		/// Unregisters the specified subclass of NSURLProtocol.		/// </summary>		/// <param name="protocolClass">The subclass of NSURLProtocol to unregister.</param>		[iOSVersion(2)]		[Export("unregisterClass")]		public static void UnregisterClass(AnyClass protocolClass) { }				/// <summary>		/// Returns the property associated with the specified key in the specified request.		/// </summary>		/// <param name="key">The key of the desired property.</param>		/// <param name="inRequest">The request whose properties are to be queried.</param>		/// <returns>The property associated with key, or nil if no property has been stored for key.</returns>		[iOSVersion(2)]		[Export("propertyForKey")]		public static AnyObject PropertyForKey(string key, NSURLRequest inRequest) { return null; }				/// <summary>		/// Sets the property associated with the specified key in the specified request.		/// </summary>		/// <param name="value">The value to set for the specified property.</param>		/// <param name="forKey">The key for the specified property.</param>		/// <param name="inRequest">The request for which to create the property.</param>		[iOSVersion(2)]		[Export("setProperty")]		public static void SetProperty(AnyObject value, string forKey, NSMutableURLRequest inRequest) { }				/// <summary>		/// Removes the property associated with the specified key in the specified request.		/// </summary>		/// <param name="key">The key whose value should be removed.</param>		/// <param name="inRequest">The request from which to remove the property value.</param>		[iOSVersion(2)]		[Export("removePropertyForKey")]		public static void RemovePropertyForKey(string key, NSMutableURLRequest inRequest) { }				/// <summary>		/// Returns whether the protocol subclass can handle the specified request.		/// </summary>		/// <param name="request">The request to be handled.</param>		/// <returns>true if the protocol subclass can handle request, otherwise false.</returns>		[iOSVersion(2)]		[Export("canInitWithRequest")]		public static bool CanInitWithRequest(NSURLRequest request) { return false; }				/// <summary>		/// Returns a canonical version of the specified request.		/// </summary>		/// <param name="request">The request whose canonical version is desired.</param>		/// <returns>The canonical form of request.</returns>		[iOSVersion(2)]		[Export("canonicalRequestForRequest")]		public static NSURLRequest CanonicalRequestForRequest(NSURLRequest request) { return null; }				/// <summary>		/// Returns whether two requests are equivalent for cache purposes.		/// </summary>		/// <param name="aRequest">The request to compare with bRequest.</param>		/// <param name="toRequest">The request to compare with aRequest.</param>		/// <returns>true if aRequest and bRequest are equivalent for cache purposes, false otherwise. Requests are considered equivalent for cache purposes if and only if they would be handled by the same protocol and that protocol declares them equivalent after performing implementation-specific checks.</returns>		[iOSVersion(2)]		[Export("requestIsCacheEquivalent")]		public static bool RequestIsCacheEquivalent(NSURLRequest aRequest, NSURLRequest toRequest) { return false; }				/// <summary>		/// Starts protocol-specific loading of the request.		/// </summary>		[iOSVersion(2)]		[Export("startLoading")]		public void StartLoading() { }				/// <summary>		/// Stops protocol-specific loading of the request.		/// </summary>		[iOSVersion(2)]		[Export("stopLoading")]		public void StopLoading() { }				/// <summary>		/// Returns the receiver’s cached response.		/// </summary>		/// <returns>The receiver's cached response.</returns>		[iOSVersion(2)]		[Export("cachedResponse")]		public NSCachedURLResponse CachedResponse { get; private set; }				/// <summary>		/// Returns the object the receiver uses to communicate with the URL loading system.		/// </summary>		/// <returns>The object the receiver uses to communicate with the URL loading system.</returns>		[iOSVersion(2)]		[Export("client")]		public NSURLProtocolClient Client { get; private set; }				/// <summary>		/// Returns the receiver’s request.		/// </summary>		/// <returns>The receiver's request.</returns>		[iOSVersion(2)]		[Export("request")]		public NSURLRequest Request { get; private set; }	}}
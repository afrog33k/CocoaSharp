using ObjectiveC;using System;using SwiftSharp.Attributes;namespace Foundation{    //https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/ApplicationKit/Classes/NSFileWrapper_Class/index.html#//apple_ref/occ/cl/NSFileWrapper    /// <summary>    /// The NSFileWrapper class provides access to the attributes and contents of file-system nodes. A file-system node is a file, directory, or symbolic link. Instances of this class are known as file wrappers.    /// </summary>    [iOSVersion(4)]    public class NSFileWrapper : NSObject    {        /// <summary>        /// Initializes a file wrapper instance whose kind is determined by the type of file-system node located by the URL.        /// </summary>        /// <param name="URL">URL of the file-system node the file wrapper is to represent.</param>        /// <param name="options">Option flags for reading the node located at url. See File Wrapper Reading Options for possible values.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>        /// <returns>File wrapper for the file-system node at url. May be a directory, file, or symbolic link, depending on what is located at the URL. Returns false (0) if reading is not successful.</returns>        [iOSVersion(4)]        public NSFileWrapper(NSURL URL, NSFileWrapperReadingOptions options, NSErrorPointer error) { }                /// <summary>        /// Initializes the receiver as a directory file wrapper, with a given file-wrapper list.        /// </summary>        /// <param name="directoryWithFileWrappers">Key-value dictionary of file wrappers with which to initialize the receiver. The dictionary must contain entries whose values are the file wrappers that are to become children and whose keys are filenames. See Working with Directory Wrappers in File System Programming Guide for more information about the file-wrapper list structure.</param>        /// <returns>Initialized file wrapper for fileWrappers.</returns>        [iOSVersion(4)]        public NSFileWrapper(NSDictionary directoryWithFileWrappers) { }                /// <summary>
        /// !! IMPORTANT !! Name the parameter you're using
        /// 
        /// Initializes the receiver as a regular-file file wrapper.
        /// Initializes the receiver as a regular-file file wrapper from given serialized data.        /// </summary>
        /// <param name="regularFileWithContents">Contents of the file.</param>
        /// <param name="serializedRepresentation">Serialized representation of a file wrapper in the format used for the NSFileContentsPboardType pasteboard type. Data of this format is returned by such methods as serializedRepresentation and RTFDFromRange:documentAttributes: (NSAttributedString).</param>
        /// <returns>Initialized regular-file file wrapper containing contents.</returns>
        /// <returns>Regular-file file wrapper initialized from serializedRepresentation.</returns>        [iOSVersion(4)]
        public NSFileWrapper(NSData regularFileWithContents, NSData serializedRepresentation) { }
        /// <summary>        /// Initializes the receiver as a symbolic-link file wrapper that links to a specified file.        /// </summary>        /// <param name="symbolicLinkWithDestinationURL">URL of the file the file wrapper is to reference.</param>        /// <returns>Initialized symbolic-link file wrapper referencing url.</returns>        [iOSVersion(4)]        public NSFileWrapper(NSURL symbolicLinkWithDestinationURL) { }                /// <summary>        /// Returns the file wrappers contained by a directory file wrapper.        /// </summary>        /// <returns>A key-value dictionary of the file wrappers contained in the directory. The dictionary contains entries whose values are the file wrappers and whose keys are the unique filenames that have been assigned to each one. See Working with Directory Wrappers in File System Programming Guide for more information about the file-wrapper list structure.</returns>        [iOSVersion(4)]        [Export("fileWrappers")]        public NSDictionary FileWrappers { get; private set; }                /// <summary>        /// Adds a child file wrapper to the receiver, which must be a directory file wrapper.        /// </summary>        /// <param name="child">File wrapper to add to the directory.</param>        /// <returns>Dictionary key used to store fileWrapper in the directory’s list of file wrappers. The dictionary key is a unique filename, which is the same as the passed-in file wrapper's preferred filename unless that name is already in use as a key in the directory’s dictionary of children. See Working with Directory Wrappers in File System Programming Guide for more information about the file-wrapper list structure.</returns>        [iOSVersion(4)]        [Export("addFileWrapper")]        public string AddFileWrapper(NSFileWrapper child) { return ""; }                /// <summary>        /// Removes a child file wrapper from the receiver, which must be a directory file wrapper.        /// </summary>        /// <param name="child">File wrapper to remove from the directory.</param>        [iOSVersion(4)]        [Export("removeFileWrapper")]        public void RemoveFileWrapper(NSFileWrapper child) { }                /// <summary>        /// Creates a regular-file file wrapper with the given contents and adds it to the receiver, which must be a directory file wrapper.        /// </summary>        /// <param name="data">Contents for the new regular-file file wrapper.</param>        /// <param name="preferredFilename">Preferred filename for the new regular-file file wrapper.</param>        /// <returns>Dictionary key used to store the new file wrapper in the directory’s list of file wrappers. The dictionary key is a unique filename, which is the same as the passed-in file wrapper's preferred filename unless that name is already in use as a key in the directory's dictionary of children. See Working with Directory Wrappers in File System Programming Guide for more information about the file-wrapper list structure.</returns>        [iOSVersion(4)]        [Export("addRegularFileWithContents")]        public string AddRegularFileWithContents(NSData data, string preferredFilename) { return ""; }                /// <summary>        /// Returns the dictionary key used by a directory to identify a given file wrapper.        /// </summary>        /// <param name="child">The child file wrapper for which you want the key.</param>        /// <returns>Dictionary key used to store the file wrapper in the directory’s list of file wrappers. The dictionary key is a unique filename, which may not be the same as the passed-in file wrapper's preferred filename if more than one file wrapper in the directory's dictionary of children has the same preferred filename. See Working with Directory Wrappers in File System Programming Guide for more information about the file-wrapper list structure. Returns nil if the file wrapper specified in child is not a child of the directory.</returns>        [iOSVersion(4)]        [Export("keyForFileWrapper")]        public string KeyForFileWrapper(NSFileWrapper child) { return ""; }                /// <summary>        /// Provides the URL referenced by the receiver, which must be a symbolic-link file wrapper.        /// </summary>        /// <returns>Pathname the file wrapper references (that is, the destination of the symbolic link the file wrapper represents).</returns>        [iOSVersion(4)]        [Export("symbolicLinkDestinationURL")]        public NSURL SymbolicLinkDestinationURL { get; private set; }                /// <summary>        /// Indicates whether the contents of a file wrapper matches a directory, regular file, or symbolic link on disk.        /// </summary>        /// <param name="url">URL of the file-system node with which to compare the file wrapper.</param>        /// <returns>true when the contents of the file wrapper match the contents of url, false otherwise.</returns>        [iOSVersion(4)]        [Export("matchesContentsOfURL")]        public bool MatchesContentsOfURL(NSURL url) { return false; }                /// <summary>        /// Recursively rereads the entire contents of a file wrapper from the specified location on disk.        /// </summary>        /// <param name="url">URL of the file-system node corresponding to the file wrapper.</param>        /// <param name="options">Option flags for reading the node located at url. See File Wrapper Reading Options for possible values.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>        /// <returns>true if successful. If not successful, returns false after setting outError to an NSError object that describes the reason why the file wrapper could not be reread.</returns>        [iOSVersion(4)]        [Export("readFromURL")]        public bool ReadFromURL(NSURL url, NSFileWrapperReadingOptions options, NSErrorPointer error) { return false; }                /// <summary>        /// Returns the contents of the file wrapper as an opaque collection of data.        /// </summary>        /// <returns>The file wrapper’s contents in the format used for the pasteboard type NSFileContentsPboardType.</returns>        [iOSVersion(4)]        [Export("serializedRepresentation")]        public NSData SerializedRepresentation { get; private set; }                /// <summary>        /// Provides the filename of a file wrapper.        /// </summary>        /// <returns>The file wrapper’s filename; nil when the file wrapper has no corresponding file-system node.</returns>        [iOSVersion(4)]        [Export("filename")]        public string Filename { get; set; }                /// <summary>        /// Provides the preferred filename for a file wrapper.        /// </summary>        /// <returns>The file wrapper’s preferred filename.</returns>        [iOSVersion(4)]        [Export("preferredFilename")]        public string PreferredFilename { get; set; }                /// <summary>        /// Returns a file wrapper’s file attributes.        /// </summary>        /// <returns>File attributes, in a dictionary of the same sort as that returned by attributesOfItemAtPath:error: (NSFileManager).</returns>        [iOSVersion(4)]        [Export("fileAttributes")]        public NSDictionary FileAttributes { get; set; }                /// <summary>        /// Returns the contents of the file-system node associated with a regular-file file wrapper.        /// </summary>        /// <returns>Contents of the file-system node the file wrapper represents.</returns>        [iOSVersion(4)]        [Export("regularFileContents")]        public NSData RegularFileContents { get; private set; }                /// <summary>        /// Recursively writes the entire contents of a file wrapper to a given file-system URL.        /// </summary>        /// <param name="url">URL of the file-system node to which the file wrapper’s contents are written.</param>        /// <param name="options">Option flags for writing to the node located at url. See File Wrapper Writing Options for possible values.</param>        /// <param name="originalContentsURL">The location of a previous revision of the contents being written. The default implementation of this method attempts to avoid unnecessary I/O by writing hard links to regular files instead of actually writing out their contents when the contents have not changed. The child file wrappers must return accurate values when sent the filename method for this to work. Use the NSFileWrapperWritingWithNameUpdating writing option to increase the likelihood of that.   Specify nil for this parameter if there is no earlier version of the contents or if you want to ensure that all the contents are written to files.</param>        /// <param name="updateNames">true to update the receiver’s filenames (its filename and—for directory file wrappers—the filenames of its sub–file wrappers) be changed to the filenames of the corresponding nodes in the file system, after a successful write operation. Use this in Save or Save As operations.   false to specify that the receiver’s filenames not be updated. Use this in Save To operations.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>        /// <returns>true when the write operation is successful. If not successful, returns false after setting outError to an NSError object that describes the reason why the file wrapper’s contents could not be written.</returns>        [iOSVersion(4)]        [Export("writeToURL")]        public bool WriteToURL(NSURL url, NSFileWrapperWritingOptions options, NSURL originalContentsURL, NSErrorPointer error) { return false; }                /// <summary>        /// Reading options that can be set by the initWithURL:options:error: and readFromURL:options:error: methods.        /// </summary>        public enum NSFileWrapperReadingOptions        {            /// <summary>            /// If reading with this option succeeds, then subsequent invocations of fileWrappers, regularFileContents, symbolicLinkDestinationURL, and serializedRepresentation sent to the file wrapper and all its child file wrappers will fail and return nil only if an actual error occurs (for example, the volume has disappeared or the file server is unreachable)—not as a result of the user moving or deleting files.            /// </summary>            [iOSVersion(4)]            Immediate,                        /// <summary>            /// Whether file mapping for regular file wrappers is disallowed.            /// </summary>            [iOSVersion(4)]            WithoutMapping,        }        /// <summary>        /// Writing options that can be set by the writeToURL:options:originalContentsURL:error: method.        /// </summary>        public enum NSFileWrapperWritingOptions        {            /// <summary>            /// Whether writing is done atomically.            /// </summary>            [iOSVersion(4)]            Atomic,                        /// <summary>            /// Whether descendant file wrappers are sent the setFilename: method if the writing succeeds.            /// </summary>            [iOSVersion(4)]            WithNameUpdating,        }    }}
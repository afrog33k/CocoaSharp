using ObjectiveC;using System;using SharpSwift.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// The NSOperationQueue class regulates the execution of a set of NSOperation objects. After being added to a queue, an operation remains in that queue until it is explicitly canceled or finishes executing its task. Operations within the queue (but not yet executing) are themselves organized according to priority levels and inter-operation object dependencies and are executed accordingly. An application may create multiple operation queues and submit operations to any of them.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSOperationQueue_class/index.html#//apple_ref/occ/cl/NSOperationQueue"/>    [iOSVersion(2)]    [Export("")]    public class NSOperationQueue : NSObject//, AnyObject, CVarArgType, Equatable, Hashable, NSObjectProtocol, Printable    {        public NSOperationQueue() { }        /// <summary>        /// Returns the operation queue that launched the current operation.        /// </summary>        [iOSVersion(4)]        [Export("currentQueue")]        [return:Optional]        public static NSOperationQueue CurrentQueue() { return default(NSOperationQueue); }                /// <summary>        /// Returns the operation queue associated with the main thread.        /// </summary>        [iOSVersion(4)]        [Export("mainQueue")]        public static NSOperationQueue MainQueue() { return default(NSOperationQueue); }                /// <summary>        /// Adds the specified operation object to the receiver.        /// </summary>        /// <param name="operation">The operation object to be added to the queue. In memory-managed applications, this object is retained by the operation queue. In garbage-collected applications, the queue strongly references the operation object.</param>        [iOSVersion(2)]        [Export("addOperation")]        public virtual void AddOperation(NSOperation operation) {  }                /// <summary>        /// Adds the specified array of operations to the queue.        /// </summary>        /// <param name="ops">The array of NSOperation objects that you want to add to the receiver.</param>        /// <param name="waitUntilFinished">If true, the current thread is blocked until all of the specified operations finish executing. If false, the operations are added to the queue and control returns immediately to the caller.</param>        [iOSVersion(4)]        [Export("addOperations")]        public virtual void AddOperations(AnyObject[] ops, bool waitUntilFinished) {  }                /// <summary>        /// Wraps the specified block in an operation object and adds it to the receiver.        /// </summary>        /// <param name="block">The block to execute from the operation object. The block should take no parameters and have no return value.</param>        [iOSVersion(4)]        [Export("addOperationWithBlock")]        public virtual void AddOperationWithBlock(Action block) {  }                /// <summary>        /// Cancels all queued and executing operations.        /// </summary>        [iOSVersion(2)]        [Export("cancelAllOperations")]        public virtual void CancelAllOperations() {  }                /// <summary>        /// Blocks the current thread until all of the receiverâ€™s queued and executing operations finish executing.        /// </summary>        [iOSVersion(2)]        [Export("waitUntilAllOperationsAreFinished")]        public virtual void WaitUntilAllOperationsAreFinished() {  }                /// <summary>        /// An array of the operations currently in the queue. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("operations")]        public AnyObject[] Operations { get; private set; }                /// <summary>        /// The number of operations currently in the queue. (read-only)        /// </summary>        [iOSVersion(4)]        [Export("operationCount")]        public int OperationCount { get; private set; }                /// <summary>        /// The default service level to apply to operations executed using the queue.        /// </summary>        [iOSVersion(8)]        [Export("qualityOfService")]        public NSQualityOfService QualityOfService { get; set; }                /// <summary>        /// The maximum number of queued operations that can execute at the same time.        /// </summary>        [iOSVersion(2)]        [Export("maxConcurrentOperationCount")]        public int MaxConcurrentOperationCount { get; set; }                /// <summary>        /// A Boolean value indicating whether the queue is actively scheduling operations for execution.        /// </summary>        [iOSVersion(8)]        [Export("suspended")]        public bool Suspended { get; set; }                /// <summary>        /// The dispatch queue used to execute operations.        /// </summary>        [iOSVersion(8)]        [Export("underlyingQueue")]        public dispatch_queue_t UnderlyingQueue { get; set; }                /// <summary>        /// The name of the operation queue.        /// </summary>        [iOSVersion(4)]        [Export("name")]        [Optional]        public string Name { get; set; }                /// <summary>        /// Constant indicating the number of supported concurrent operations.        /// </summary>        public int NSOperationQueueDefaultMaxConcurrentOperationCount { get; private set; }    }}
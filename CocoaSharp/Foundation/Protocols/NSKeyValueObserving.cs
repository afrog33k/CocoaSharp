using ObjectiveC;using System;using SwiftSharp.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// The NSKeyValueObserving (KVO) informal protocol defines a mechanism that allows objects to be notified of changes to the specified properties of other objects.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/index.html#//apple_ref/doc/uid/TP40003781"/>    [iOSVersion(2)]    public interface NSKeyValueObserving//:    {    }    /// <summary>    /// These constants are returned as the value for a NSKeyValueChangeKindKey key in the change dictionary passed to observeValueForKeyPath:ofObject:change:context: indicating the type of change made:    /// </summary>    [iOSVersion(2)]    public enum NSKeyValueChange    {        /// <summary>        /// Indicates that the value of the observed key path was set to a new value. This change can occur when observing an attribute of an object, as well as properties that specify to-one and to-many relationships.        /// </summary>        [iOSVersion(2)]        Setting,        /// <summary>        /// Indicates that an object has been inserted into the to-many relationship that is being observed.        /// </summary>        [iOSVersion(2)]        Insertion,        /// <summary>        /// Indicates that an object has been removed from the to-many relationship that is being observed.        /// </summary>        [iOSVersion(2)]        Removal,        /// <summary>        /// Indicates that an object has been replaced in the to-many relationship that is being observed.        /// </summary>        [iOSVersion(2)]        Replacement,    }    /// <summary>    /// These constants are passed to addObserver:forKeyPath:options:context: and determine the values that are returned as part of the change dictionary passed to an observeValueForKeyPath:ofObject:change:context:. You can pass 0 if you require no change dictionary values.    /// </summary>    [iOSVersion(2)]    public enum NSKeyValueObservingOptions    {        /// <summary>        /// Indicates that the change dictionary should provide the new attribute value, if applicable.        /// </summary>        [iOSVersion(2)]        New,        /// <summary>        /// Indicates that the change dictionary should contain the old attribute value, if applicable.        /// </summary>        [iOSVersion(2)]        Old,        /// <summary>        /// If specified, a notification should be sent to the observer immediately, before the observer registration method even returns.        /// The change dictionary in the notification will always contain an NSKeyValueChangeNewKey entry if NSKeyValueObservingOptionNew is also specified but will never contain an NSKeyValueChangeOldKey entry. (In an initial notification the current value of the observed property may be old, but it's new to the observer.) You can use this option instead of explicitly invoking, at the same time, code that is also invoked by the observer's observeValueForKeyPath:ofObject:change:context: method. When this option is used withaddObserver:forKeyPath:options:context: a notification will be sent for each indexed object to which the observer is being added.        /// </summary>        [iOSVersion(2)]        Initial,        /// <summary>        /// Whether separate notifications should be sent to the observer before and after each change, instead of a single notification after the change.        /// The change dictionary in a notification sent before a change always contains an NSKeyValueChangeNotificationIsPriorKey entry whose value is [NSNumber numberWithBool:YES], but never contains an NSKeyValueChangeNewKey entry. When this option is specified the change dictionary in a notification sent after a change contains the same entries that it would contain if this option were not specified. You can use this option when the observer's own key-value observing-compliance requires it to invoke one of the -willChange... methods for one of its own properties, and the value of that property depends on the value of the observed object's property. (In that situation it's too late to easily invoke -willChange... properly in response to receiving an observeValueForKeyPath:ofObject:change:context: message after the change.)        /// </summary>        [iOSVersion(2)]        Prior,    }    /// <summary>    /// These constants are specified as the parameter to the methods willChangeValueForKey:withSetMutation:usingObjects: and didChangeValueForKey:withSetMutation:usingObjects:. Their semantics correspond exactly to the NSMutableSet class methods unionSet:, minusSet:, intersectSet:, and setSet: method, respectively.    /// </summary>    [iOSVersion(2)]    public enum NSKeyValueSetMutationKind    {        /// <summary>        /// Indicates that objects in the specified set are being added to the receiver.        /// This mutation kind results in a NSkeyValueChangeKindKey value of NSKeyValueChangeInsertion.        /// </summary>        [iOSVersion(2)]        UnionSetMutation,        /// <summary>        /// Indicates that the objects in the specified set are being removed from the receiver.        /// This mutation kind results in a NSkeyValueChangeKindKey value of NSKeyValueChangeRemoval.        /// </summary>        [iOSVersion(2)]        MinusSetMutation,        /// <summary>        /// Indicates that the objects not in the specified set are being removed from the receiver.        /// This mutation kind results in a NSkeyValueChangeKindKey value of NSKeyValueChangeRemoval.        /// </summary>        [iOSVersion(2)]        IntersectSetMutation,        /// <summary>        /// Indicates that set of objects are replacing the existing objects in the receiver.        /// This mutation kind results in a NSKeyValueChangeKindKey value of NSKeyValueChangeReplacement.        /// </summary>        [iOSVersion(2)]        SetSetMutation,    }}
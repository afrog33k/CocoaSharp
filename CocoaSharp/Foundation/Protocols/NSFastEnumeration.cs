using ObjectiveC;using System;using SwiftSharp.Attributes;namespace Foundation{    //https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/NSFastEnumeration_protocol/index.html#//apple_ref/occ/intf/NSFastEnumeration    /// <summary>    /// The fast enumeration protocol NSFastEnumeration must be adopted and implemented by objects used in conjunction with the for language construct used in conjunction with Cocoa objects.    /// </summary>    [iOSVersion(2)]    public interface NSFastEnumeration    {        /// <summary>        /// Returns by reference a C array of objects over which the sender should iterate, and as the return value the number of objects in the array. (required)        /// </summary>        /// <param name="state">Context information that is used in the enumeration to, in addition to other possibilities, ensure that the collection has not been mutated.</param>        /// <param name="objects">A C array of objects over which the sender is to iterate.</param>        /// <param name="count">The maximum number of objects to return in stackbuf.</param>        /// <returns>The number of objects returned in stackbuf. Returns 0 when the iteration is finished.</returns>        [iOSVersion(2)]        [Export("countByEnumeratingWithState")]        int CountByEnumeratingWithState(CMutablePointer<NSFastEnumerationState> state, AutoreleasingUnsafePointer<AnyObject> objects, int count);    }

    public struct NSFastEnumerationState
    {
        CUnsignedLong state { get; set; }
        UnsafePointer<AnyObject> itemsPtr { get; set; }
        private UnsafePointer<CUnsignedLong> mutationsPtr { get; set; }
        Tuple<CUnsignedLong, CUnsignedLong, CUnsignedLong, CUnsignedLong, CUnsignedLong> extra { get; set; }
    } }
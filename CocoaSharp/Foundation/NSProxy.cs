using ObjectiveC;using System;using SwiftSharp.Attributes;namespace Foundation{	//https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/cl/NSProxy	/// <summary>	/// NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that donâ€™t exist yet. Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.	/// </summary>	[iOSVersion(2)]	public class NSProxy : 	{		/// <summary>		/// Returns a new instance of the receiving class		/// </summary>		[iOSVersion(2)]		[Export("alloc")]		public static NSProxy Alloc() { return null; }				/// <summary>		/// Deallocates the memory occupied by the receiver.		/// </summary>		[iOSVersion(2)]		[Export("dealloc")]		public void Dealloc() { }				/// <summary>		/// The garbage collector invokes this method on the receiver before disposing of the memory it uses.		/// </summary>		[iOSVersion(2)]		[Export("finalize")]		public void Finalize() { }				/// <summary>		/// Passes a given invocation to the real object the proxy represents.		/// </summary>		/// <param name="anInvocation">The invocation to forward.</param>		[iOSVersion(2)]		[Export("forwardInvocation")]		public void ForwardInvocation(NSInvocation anInvocation) { }				/// <summary>		/// Raises NSInvalidArgumentException. Override this method in your concrete subclass to return a proper NSMethodSignature object for the given selector and the class your proxy objects stand in for.		/// </summary>		/// <param name="aSelector">The selector for which to return a method signature.</param>		/// <returns>Not applicable. The implementation provided by NSProxy raises an exception.</returns>		[iOSVersion(2)]		[Export("methodSignatureForSelector")]		public NSMethodSignature MethodSignatureForSelector(Selector aSelector) { return null; }				/// <summary>		/// Returns a Boolean value that indicates whether the receiving class responds to a given selector.		/// </summary>		/// <param name="aSelector">A selector.</param>		/// <returns>true if the receiving class responds to aSelector messages, otherwise false.</returns>		[iOSVersion(2)]		[Export("respondsToSelector")]		public static bool RespondsToSelector(Selector aSelector) { return false; }				/// <summary>		/// Returns self (the class object).		/// </summary>		/// <returns>self. Because this is a class method, it returns the class object</returns>		[iOSVersion(2)]		[Export("class")]		public static AnyClass class() { return null; }				/// <summary>		/// Returns an NSString object containing the real class name and the id of the receiver as a hexadecimal number.		/// </summary>		/// <returns>An NSString object containing the real class name and the id of the receiver as a hexadecimal number.</returns>		[iOSVersion(2)]		[Export("description")]		public string Description { get; private set; }				/// <summary>		/// Returns an string containing the real class name and the id of the receiver as a hexadecimal number.		/// </summary>		/// <returns>A string object containing the real class name and the id of the receiver as a hexadecimal number.</returns>		[iOSVersion(5)]		[Export("debugDescription")]		public string DebugDescription { get; private set; }	}}
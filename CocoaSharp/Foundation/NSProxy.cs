using ObjectiveC;using System;using SwiftSharp.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// NSProxy is an abstract superclass defining an API for objects that act as stand-ins for other objects or for objects that donâ€™t exist yet. Typically, a message to a proxy is forwarded to the real object or causes the proxy to load (or transform itself into) the real object. Subclasses of NSProxy can be used to implement transparent distributed messaging (for example, NSDistantObject) or for lazy instantiation of objects that are expensive to create.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html#//apple_ref/occ/cl/NSProxy"/>    [iOSVersion(2)]    public class NSProxy//: AnyObject, NSObjectProtocol    {        /// <summary>        /// Returns a new instance of the receiving class        /// </summary>        [iOSVersion(2)]        [Export("alloc")]        public static NSProxy Alloc() { return default(NSProxy); }                /// <summary>        /// Deallocates the memory occupied by the receiver.        /// </summary>        [iOSVersion(2)]        [Export("dealloc")]        public void Dealloc() {  }                /// <summary>        /// The garbage collector invokes this method on the receiver before disposing of the memory it uses.        /// </summary>        [iOSVersion(2)]        [Export("finalize")]        public void Finalize() {  }                /// <summary>        /// Passes a given invocation to the real object the proxy represents.        /// </summary>        /// <param name="anInvocation">The invocation to forward.</param>        [iOSVersion(2)]        [Export("forwardInvocation")]        public void ForwardInvocation(NSInvocation anInvocation) {  }                /// <summary>        /// Raises NSInvalidArgumentException. Override this method in your concrete subclass to return a proper NSMethodSignature object for the given selector and the class your proxy objects stand in for.        /// </summary>        /// <param name="aSelector">The selector for which to return a method signature.</param>        [iOSVersion(2)]        [Export("methodSignatureForSelector")]        public NSMethodSignature MethodSignatureForSelector(Selector aSelector) { return default(NSMethodSignature); }                /// <summary>        /// Returns a Boolean value that indicates whether the receiving class responds to a given selector.        /// </summary>        /// <param name="aSelector">A selector.</param>        [iOSVersion(2)]        [Export("respondsToSelector")]        public static bool RespondsToSelector(Selector aSelector) { return default(bool); }                /// <summary>        /// Returns self (the class object).        /// </summary>        [iOSVersion(2)]        public static AnyClass @class() { return default(AnyClass); }                /// <summary>        /// Returns an NSString object containing the real class name and the id of the receiver as a hexadecimal number.        /// </summary>        [iOSVersion(2)]        [Export("description")]        public string Description { get; private set; }                /// <summary>        /// Returns an string containing the real class name and the id of the receiver as a hexadecimal number.        /// </summary>        [iOSVersion(5)]        [Export("debugDescription")]        public string DebugDescription { get; private set; }    }}
using ObjectiveC;using System;using SwiftSharp.Attributes;using System.Collections.Generic;namespace Foundation{	/// <summary>	/// An NSFileManager object lets you examine the contents of the file system and make changes to it. A file manager object is usually your first interaction with the file system. You use it to locate, create, copy, and move files and directories. You also use it to get information about a file or directory or change some of its attributes.	/// </summary>	/// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSFileManager_Class/index.html#//apple_ref/occ/cl/NSFileManager"/>	[iOSVersion(2)]	public class NSFileManager : NSObject//, AnyObject, NSObjectProtocol	{		/// <summary>		/// Returns the shared file manager object for the process.		/// </summary>		[iOSVersion(2)]		[Export("defaultManager")]		public static NSFileManager DefaultManager() { return default(NSFileManager); }				/// <summary>		/// Locates and optionally creates the specified common directory in a domain.		/// </summary>		/// <param name="directory">The search path directory. The supported values are described in NSSearchPathDirectory.</param>		/// <param name="inDomain">The file system domain to search. The value for this parameter is one of the constants described in NSSearchPathDomainMask. You should specify only one domain for your search and you may not specify the NSAllDomainsMask constant for this parameter.</param>		/// <param name="appropriateForURL">The name of a directory inside of which you want to create a unique temporary directory for autosaving documents or some other use. This parameter is ignored unless the directory parameter contains the value NSItemReplacementDirectory and the domain parameter contains the value NSUserDomainMask. When creating a temporary directory, the shouldCreate parameter is ignored and the directory is always created.</param>		/// <param name="create">Specify true if you want the directory to be created if it does not exist.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		public NSURL URLForDirectory(NSSearchPathDirectory directory, NSSearchPathDomainMask inDomain, NSURL appropriateForURL, bool create, NSErrorPointer error) { return default(NSURL); }				/// <summary>		/// Returns an array of URLs for the specified common directory in the requested domains.		/// </summary>		/// <param name="directory">The search path directory. The supported values are described in NSSearchPathDirectory.</param>		/// <param name="inDomains">The file system domain to search. The value for this parameter is one or more of the constants described in NSSearchPathDomainMask.</param>		[iOSVersion(4)]		public AnyObject[] URLsForDirectory(NSSearchPathDirectory directory, NSSearchPathDomainMask inDomains) { return default(AnyObject[]); }				/// <summary>		/// Returns the container directory associated with the specified security application group ID.		/// </summary>		/// <param name="groupIdentifier"></param>		[iOSVersion(7)]		[Export("containerURLForSecurityApplicationGroupIdentifier")]		public NSURL ContainerURLForSecurityApplicationGroupIdentifier(string groupIdentifier) { return default(NSURL); }				/// <summary>		/// Performs a shallow search of the specified directory and returns URLs for the contained items.		/// </summary>		/// <param name="url">The URL for the directory whose contents you want to enumerate.</param>		/// <param name="includingPropertiesForKeys">An array of keys that identify the file properties that you want pre-fetched for each item in the directory. For each returned URL, the specified properties are fetched and cached in the NSURL object. For a list of keys you can specify, see Common File System Resource Keys.</param>		/// <param name="options">Options for the enumeration. Because this method performs only shallow enumerations, options that prevent descending into subdirectories or packages are not allowed; the only supported option is  NSDirectoryEnumerationSkipsHiddenFiles.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		[Export("contentsOfDirectoryAtURL")]		public AnyObject[] ContentsOfDirectoryAtURL(NSURL url, AnyObject[] includingPropertiesForKeys, NSDirectoryEnumerationOptions options, NSErrorPointer error) { return default(AnyObject[]); }				/// <summary>		/// Performs a shallow search of the specified directory and returns the paths of any contained items.		/// </summary>		/// <param name="path">The path to the directory whose contents you want to enumerate.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("contentsOfDirectoryAtPath")]		public AnyObject[] ContentsOfDirectoryAtPath(string path, NSErrorPointer error) { return default(AnyObject[]); }				/// <summary>		/// Returns a directory enumerator object that can be used to perform a deep enumeration of the directory at the specified URL.		/// </summary>		/// <param name="url">The location of the directory for which you want an enumeration. This URL must not be a symbolic link that points to the desired directory. You can use the URLByResolvingSymlinksInPath method to resolve any symlinks in the URL.</param>		/// <param name="includingPropertiesForKeys">An array of keys that identify the properties that you want pre-fetched for each item in the enumeration. The values for these keys are cached in the corresponding NSURL objects. You may specify nil for this parameter. For a list of keys you can specify, see Common File System Resource Keys.</param>		/// <param name="options">Options for the enumeration. For a list of valid options, see Directory Enumeration Options.</param>		/// <param name="errorHandler">An optional error handler block for the file manager to call when an error occurs. The handler block should return true if you want the enumeration to continue or false if you want the enumeration to stop. The block takes the following parameters:  		///       url		///   An NSURL object that identifies the item for which the error occurred. 		///       error		///   An NSError object that contains information about the error.		///   If you specify nil for this parameter, the enumerator object continues to enumerator items as if you had specified a block that returned true.</param>		[iOSVersion(4)]		[Export("enumeratorAtURL")]		public NSDirectoryEnumerator EnumeratorAtURL(NSURL url, AnyObject[] includingPropertiesForKeys, NSDirectoryEnumerationOptions options, Func<NSURL, NSError, bool> errorHandler) { return default(NSDirectoryEnumerator); }				/// <summary>		/// Returns a directory enumerator object that can be used to perform a deep enumeration of the directory at the specified path.		/// </summary>		/// <param name="path">The path of the directory to enumerate.</param>		[iOSVersion(2)]		[Export("enumeratorAtPath")]		public NSDirectoryEnumerator EnumeratorAtPath(string path) { return default(NSDirectoryEnumerator); }				/// <summary>		/// Returns an array of URLs that identify the mounted volumes available on the computer.		/// </summary>		/// <param name="propertyKeys">An array of keys that identify the file properties that you want pre-fetched for each volume. For each returned URL, the values for these keys are cached in the corresponding NSURL objects. You may specify nil for this parameter. For a list of keys you can specify, see Common File System Resource Keys.</param>		/// <param name="options">Option flags for the enumeration. For a list of possible values, see NSVolumeEnumerationOptions.</param>		[iOSVersion(4)]		[Export("mountedVolumeURLsIncludingResourceValuesForKeys")]		public AnyObject[] MountedVolumeURLsIncludingResourceValuesForKeys(AnyObject[] propertyKeys, NSVolumeEnumerationOptions options) { return default(AnyObject[]); }				/// <summary>		/// Performs a deep enumeration of the specified directory and returns the paths of all of the contained subdirectories.		/// </summary>		/// <param name="path">The path of the directory to list.</param>		/// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>		[iOSVersion(2)]		[Export("subpathsOfDirectoryAtPath")]		public AnyObject[] SubpathsOfDirectoryAtPath(string path, NSErrorPointer error) { return default(AnyObject[]); }				/// <summary>		/// Returns an array of strings identifying the paths for all items in the specified directory.		/// </summary>		/// <param name="path">The path of the directory to list.</param>		[iOSVersion(2)]		[Export("subpathsAtPath")]		public AnyObject[] SubpathsAtPath(string path) { return default(AnyObject[]); }				/// <summary>		/// Creates a directory with the given attributes at the specified URL.		/// </summary>		/// <param name="url">A file URL that specifies the directory to create. If you want to specify a relative path, you must set the current working directory before creating the corresponding NSURL object. This parameter must not be nil.</param>		/// <param name="withIntermediateDirectories">If true, this method creates any non-existent parent directories as part of creating the directory in url. If false, this method fails if any of the intermediate parent directories does not exist.</param>		/// <param name="attributes">The file attributes for the new directory. You can set the owner and group numbers, file permissions, and modification date. If you specify nil for this parameter, the directory is created according to the umask(2) Mac OS X Developer Tools		///  Manual Page of the process. The Constants section lists the global constants used as keys in the attributes dictionary. Some of the keys, such as NSFileHFSCreatorCode and NSFileHFSTypeCode, do not apply to directories.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(5)]		[Export("createDirectoryAtURL")]		public bool CreateDirectoryAtURL(NSURL url, bool withIntermediateDirectories, Dictionary<NSObject, AnyObject> attributes, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Creates a directory with given attributes at the specified path.		/// </summary>		/// <param name="path">A path string identifying the directory to create. You may specify a full path or a path that is relative to the current working directory. This parameter must not be nil.</param>		/// <param name="withIntermediateDirectories">If true, this method creates any non-existent parent directories as part of creating the directory in path. If false, this method fails if any of the intermediate parent directories does not exist. This method also fails if any of the intermediate path elements corresponds to a file and not a directory.</param>		/// <param name="attributes">The file attributes for the new directory and any newly created intermediate directories. You can set the owner and group numbers, file permissions, and modification date. If you specify nil for this parameter or omit a particular value, one or more default values are used as described in the discussion. For a list of keys you can include in this dictionary, see Constants section lists the global constants used as keys in the attributes dictionary. Some of the keys, such as NSFileHFSCreatorCode and NSFileHFSTypeCode, do not apply to directories.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("createDirectoryAtPath")]		public bool CreateDirectoryAtPath(string path, bool withIntermediateDirectories, Dictionary<NSObject, AnyObject> attributes, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Creates a file with the specified content and attributes at the given location.		/// </summary>		/// <param name="path">The path for the new file.</param>		/// <param name="contents">A data object containing the contents of the new file.</param>		/// <param name="attributes">A dictionary containing the attributes to associate with the new file. You can use these attributes to set the owner and group numbers, file permissions, and modification date. For a list of keys, see File Attribute Keys. If you specify nil for attributes, the file is created with a set of default attributes.</param>		[iOSVersion(2)]		[Export("createFileAtPath")]		public bool CreateFileAtPath(string path, NSData contents, Dictionary<NSObject, AnyObject> attributes) { return default(bool); }				/// <summary>		/// Removes the file or directory at the specified URL.		/// </summary>		/// <param name="URL">A file URL specifying the file or directory to remove. If the URL specifies a directory, the contents of that directory are recursively removed. You may specify nil for this parameter.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		[Export("removeItemAtURL")]		public bool RemoveItemAtURL(NSURL URL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Removes the file or directory at the specified path.		/// </summary>		/// <param name="path">A path string indicating the file or directory to remove. If the path specifies a directory, the contents of that directory are recursively removed. You may specify nil for this parameter.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("removeItemAtPath")]		public bool RemoveItemAtPath(string path, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Replaces the contents of the item at the specified URL in a manner that insures no data loss occurs.		/// </summary>		/// <param name="originalItemURL">The item whose contents you want to replace.</param>		/// <param name="withItemAtURL">The item containing the new content for originalItemURL. It is recommended that you put this item in a temporary directory as provided by the OS. If a temporary directory is not available, put this item in a uniquely named directory that is in the same directory as the original item.</param>		/// <param name="backupItemName">Optional. If provided, this name is used to create a backup of the original item.		///   The backup is placed in the same directory as the original item. If an error occurs during the creation of the backup item, the operation will fail. If there is already an item with the same name as the backup item, that item will be removed.		///   The backup item will be removed in the event of success unless the NSFileManagerItemReplacementWithoutDeletingBackupItem option is provided in options.</param>		/// <param name="options">Specifies the options to use during the replacement. Typically, you pass NSFileManagerItemReplacementUsingNewMetadataOnly for this parameter, which uses only the metadata from the new item. You can also combine the options described in NSFileManagerItemReplacementOptions using the C-bitwise OR operator.</param>		/// <param name="resultingItemURL">On input, a pointer for a URL object. When the item is replaced, this pointer is set to the URL of the new item. If no new file system object is required, the URL object in this parameter may be the same passed to the originalItemURL parameter. However, if a new file system object is required, the URL object may be different. For example, replacing an RTF document with an RTFD document requires the creation of a new file.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		[Export("replaceItemAtURL")]		public bool ReplaceItemAtURL(NSURL originalItemURL, NSURL withItemAtURL, string backupItemName, NSFileManagerItemReplacementOptions options, AutoreleasingUnsafePointer<NSURL> resultingItemURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Copies the file at the specified URL to a new location synchronously.		/// </summary>		/// <param name="srcURL">The file URL that identifies the file you want to copy. The URL in this parameter must not be a file reference URL. This parameter must not be nil.</param>		/// <param name="toURL">The URL at which to place the copy of srcURL. The URL in this parameter must not be a file reference URL and must include the name of the file in its new location. This parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		[Export("copyItemAtURL")]		public bool CopyItemAtURL(NSURL srcURL, NSURL toURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Copies the item at the specified path to a new location synchronously.		/// </summary>		/// <param name="srcPath">The path to the file or directory you want to move. This parameter must not be nil.</param>		/// <param name="toPath">The path at which to place the copy of srcPath. This path must include the name of the file or directory in its new location. This parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("copyItemAtPath")]		public bool CopyItemAtPath(string srcPath, string toPath, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Moves the file or directory at the specified URL to a new location synchronously.		/// </summary>		/// <param name="srcURL">The file URL that identifies the file or directory you want to move. The URL in this parameter must not be a file reference URL. This parameter must not be nil.</param>		/// <param name="toURL">The new location for the item in srcURL. The URL in this parameter must not be a file reference URL and must include the name of the file or directory in its new location. This parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		[Export("moveItemAtURL")]		public bool MoveItemAtURL(NSURL srcURL, NSURL toURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Moves the file or directory at the specified path to a new location synchronously.		/// </summary>		/// <param name="srcPath">The path to the file or directory you want to move. This parameter must not be nil.</param>		/// <param name="toPath">The new path for the item in srcPath. This path must include the name of the file or directory in its new location. This parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("moveItemAtPath")]		public bool MoveItemAtPath(string srcPath, string toPath, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Returns the URL for the iCloud container associated with the specified identifier and establishes access to that container.		/// </summary>		/// <param name="containerID">The fully-qualified container identifier for an iCloud container directory. The string you specify must not contain wildcards and must be of the form <TEAMID>.<CONTAINER>, where <TEAMID> is your development team ID and <CONTAINER> is the bundle identifier of the container you want to access.		///   The container identifiers for your app must be declared in the com.apple.developer.ubiquity-container-identifiers array of the .entitlements property list file in your Xcode project.		///   If you specify nil for this parameter, this method returns the first container listed in the com.apple.developer.ubiquity-container-identifiers entitlement array.</param>		[iOSVersion(5)]		public NSURL URLForUbiquityContainerIdentifier(string containerID) { return default(NSURL); }				/// <summary>		/// Returns a Boolean indicating whether the item is targeted for storage in iCloud.		/// </summary>		/// <param name="url">Specify the URL for the file or directory whose status you want to check.</param>		[iOSVersion(5)]		[Export("isUbiquitousItemAtURL")]		public bool IsUbiquitousItemAtURL(NSURL url) { return default(bool); }				/// <summary>		/// Sets whether the item at the specified URL should be stored in the cloud.		/// </summary>		/// <param name="flag">Specify true to move the item to iCloud or false to remove it from iCloud (if it is there currently).</param>		/// <param name="itemAtURL">Specify the URL of the item (file or directory) that you want to store in iCloud.</param>		/// <param name="destinationURL">Moving a file into iCloud Specify the location in iCloud at which to store the file or directory. This URL must be constructed from a URL returned by the URLForUbiquityContainerIdentifier: method, which you use to retrieve the desired iCloud container directory. The URL you specify may contain additional subdirectories so that you can organize your files hierarchically in iCloud. However, you are responsible for creating those intermediate subdirectories (using the NSFileManager class) in your iCloud container directory.		///   Moving a file out of iCloud Specify the location on the local device.</param>		/// <param name="error">On input, a pointer to variable for an NSError object. If an error occurs, this pointer is set to an NSError object containing information about the error. You may specify nil to ignore the error information.</param>		[iOSVersion(5)]		[Export("setUbiquitous")]		public bool SetUbiquitous(bool flag, NSURL itemAtURL, NSURL destinationURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Starts downloading (if necessary) the specified item to the local system.		/// </summary>		/// <param name="url">Specify the URL for the file or directory in the cloud that you want to download.</param>		/// <param name="error">On input, a pointer to variable for an NSError object. If an error occurs, this pointer is set to an NSError object containing information about the error. You may specify nil to ignore the error information.</param>		[iOSVersion(5)]		[Export("startDownloadingUbiquitousItemAtURL")]		public bool StartDownloadingUbiquitousItemAtURL(NSURL url, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Removes the local copy of the specified cloud-based item.		/// </summary>		/// <param name="url">Specify the URL to a file or directory in iCloud storage.</param>		/// <param name="error">On input, a pointer to variable for an NSError object. If an error occurs, this pointer is set to an NSError object containing information about the error. You may specify nil to ignore the error information.</param>		[iOSVersion(5)]		[Export("evictUbiquitousItemAtURL")]		public bool EvictUbiquitousItemAtURL(NSURL url, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Returns a URL that can be emailed to users to allow them to download a copy of a cloud-based item.		/// </summary>		/// <param name="url">Specify the URL of the item in the cloud that you want to share. The URL must be prefixed with the base URL returned from the URLForUbiquityContainerIdentifier: method that corresponds to the item’s location. The file at the specified URL must already be uploaded to iCloud when you call this method.</param>		/// <param name="expirationDate">On input, a pointer to a variable for a date object. On output, this parameter contains the date after which the item is no longer available at the returned URL. You may specify nil for this parameter if you are not interested in the date.</param>		/// <param name="error">On input, a pointer to variable for an NSError object. If an error occurs, this pointer is set to an NSError object containing information about the error. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(5)]		public NSURL URLForPublishingUbiquitousItemAtURL(NSURL url, AutoreleasingUnsafePointer<NSDate> expirationDate, NSErrorPointer error) { return default(NSURL); }				/// <summary>		/// Creates a symbolic link at the specified URL that points to an item at the given URL.		/// </summary>		/// <param name="url">The file URL at which to create the new symbolic link. The last path component of the URL issued as the name of the link.</param>		/// <param name="withDestinationURL">The file URL that contains the item to be pointed to by the link. In other words, this is the destination of the link.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(5)]		[Export("createSymbolicLinkAtURL")]		public bool CreateSymbolicLinkAtURL(NSURL url, NSURL withDestinationURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Creates a symbolic link that points to the specified destination.		/// </summary>		/// <param name="path">The path at which to create the new symbolic link. The last path component is used as the name of the link.</param>		/// <param name="withDestinationPath">The path that contains the item to be pointed to by the link. In other words, this is the destination of the link.</param>		/// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>		[iOSVersion(2)]		[Export("createSymbolicLinkAtPath")]		public bool CreateSymbolicLinkAtPath(string path, string withDestinationPath, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Creates a hard link between the items at the specified URLs.		/// </summary>		/// <param name="srcURL">The file URL that identifies the source of the link. The URL in this parameter must not be a file reference URL; it must specify the actual path to the item. The value in this parameter must not be nil.</param>		/// <param name="toURL">The file URL that specifies where you want to create the hard link. The URL in this parameter must not be a file reference URL; it must specify the actual path to the item. The value in this parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(4)]		[Export("linkItemAtURL")]		public bool LinkItemAtURL(NSURL srcURL, NSURL toURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Creates a hard link between the items at the specified paths.		/// </summary>		/// <param name="srcPath">The path that specifies the item you wish to link to. The value in this parameter must not be nil.</param>		/// <param name="toPath">The path that identifies the location where the link will be created. The value in this parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("linkItemAtPath")]		public bool LinkItemAtPath(string srcPath, string toPath, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Returns the path of the item pointed to by a symbolic link.		/// </summary>		/// <param name="path">The path of a file or directory.</param>		/// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>		[iOSVersion(2)]		[Export("destinationOfSymbolicLinkAtPath")]		public string DestinationOfSymbolicLinkAtPath(string path, NSErrorPointer error) { return default(string); }				/// <summary>		/// Returns a Boolean value that indicates whether a file or directory exists at a specified path.		/// </summary>		/// <param name="path">The path of the file or directory. If path begins with a tilde (~), it must first be expanded with stringByExpandingTildeInPath, otherwise, this method returns false.</param>		[iOSVersion(2)]		[Export("fileExistsAtPath")]		public bool FileExistsAtPath(string path) { return default(bool); }				/// <summary>		/// Returns a Boolean value that indicates whether a file or directory exists at a specified path.		/// </summary>		/// <param name="path">The path of a file or directory. If path begins with a tilde (~), it must first be expanded with stringByExpandingTildeInPath, or this method will return false.</param>		/// <param name="isDirectory">Upon return, contains true if path is a directory or if the final path element is a symbolic link that points to a directory, otherwise contains false. If path doesn’t exist, this value is undefined upon return. Pass NULL if you do not need this information.</param>		[iOSVersion(2)]		[Export("fileExistsAtPath")]		public bool FileExistsAtPath(string path, UnsafePointer<ObjCBool> isDirectory) { return default(bool); }				/// <summary>		/// Returns a Boolean value that indicates whether the invoking object appears able to read a specified file.		/// </summary>		/// <param name="path">A file path.</param>		[iOSVersion(2)]		[Export("isReadableFileAtPath")]		public bool IsReadableFileAtPath(string path) { return default(bool); }				/// <summary>		/// Returns a Boolean value that indicates whether the invoking object appears able to write to a specified file.		/// </summary>		/// <param name="path">A file path.</param>		[iOSVersion(2)]		[Export("isWritableFileAtPath")]		public bool IsWritableFileAtPath(string path) { return default(bool); }				/// <summary>		/// Returns a Boolean value that indicates whether the operating system appears able to execute a specified file.		/// </summary>		/// <param name="path">A file path.</param>		[iOSVersion(2)]		[Export("isExecutableFileAtPath")]		public bool IsExecutableFileAtPath(string path) { return default(bool); }				/// <summary>		/// Returns a Boolean value that indicates whether the invoking object appears able to delete a specified file.		/// </summary>		/// <param name="path">A file path.</param>		[iOSVersion(2)]		[Export("isDeletableFileAtPath")]		public bool IsDeletableFileAtPath(string path) { return default(bool); }				/// <summary>		/// Returns an array of strings representing the user-visible components of a given path.		/// </summary>		/// <param name="path">A pathname.</param>		[iOSVersion(2)]		[Export("componentsToDisplayForPath")]		public AnyObject[] ComponentsToDisplayForPath(string path) { return default(AnyObject[]); }				/// <summary>		/// Returns the display name of the file or directory at a specified path.		/// </summary>		/// <param name="path">The path of a file or directory.</param>		[iOSVersion(2)]		[Export("displayNameAtPath")]		public string DisplayNameAtPath(string path) { return default(string); }				/// <summary>		/// Returns the attributes of the item at a given path.		/// </summary>		/// <param name="path">The path of a file or directory.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("attributesOfItemAtPath")]		public Dictionary<NSObject, AnyObject> AttributesOfItemAtPath(string path, NSErrorPointer error) { return default(Dictionary<NSObject, AnyObject>); }				/// <summary>		/// Returns a dictionary that describes the attributes of the mounted file system on which a given path resides.		/// </summary>		/// <param name="path">Any pathname within the mounted file system.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("attributesOfFileSystemForPath")]		public Dictionary<NSObject, AnyObject> AttributesOfFileSystemForPath(string path, NSErrorPointer error) { return default(Dictionary<NSObject, AnyObject>); }				/// <summary>		/// Sets the attributes of the specified file or directory.		/// </summary>		/// <param name="attributes">A dictionary containing as keys the attributes to set for path and as values the corresponding value for the attribute. You can set the following attributes: NSFileBusy, NSFileCreationDate, NSFileExtensionHidden, NSFileGroupOwnerAccountID, NSFileGroupOwnerAccountName, NSFileHFSCreatorCode, NSFileHFSTypeCode, NSFileImmutable, NSFileModificationDate, NSFileOwnerAccountID, NSFileOwnerAccountName, NSFilePosixPermissions. You can change single attributes or any combination of attributes; you need not specify keys for all attributes.</param>		/// <param name="ofItemAtPath">The path of a file or directory.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(2)]		[Export("setAttributes")]		public bool SetAttributes(Dictionary<NSObject, AnyObject> attributes, string ofItemAtPath, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Returns the contents of the file at the specified path.		/// </summary>		/// <param name="path">The path of the file whose contents you want.</param>		[iOSVersion(2)]		[Export("contentsAtPath")]		public NSData ContentsAtPath(string path) { return default(NSData); }				/// <summary>		/// Returns a Boolean value that indicates whether the files or directories in specified paths have the same contents.		/// </summary>		/// <param name="path1">The path of a file or directory to compare with the contents of path2.</param>		/// <param name="andPath">The path of a file or directory to compare with the contents of path1.</param>		[iOSVersion(2)]		[Export("contentsEqualAtPath")]		public bool ContentsEqualAtPath(string path1, string andPath) { return default(bool); }				/// <summary>		/// Determines the type of relationship that exists between a directory and item.		/// </summary>		/// <param name="outRelationship">A pointer to a variable in which to put the relationship between directoryURL and otherURL. For a list of possible values, see NSURLRelationship.</param>		/// <param name="ofDirectoryAtURL">The URL of the directory that potentially contains the item in otherURL. The URL in this parameter must specify a directory. This parameter must not be nil.</param>		/// <param name="toItemAtURL">The URL of the file or directory whose relationship to directoryURL is being tested. This parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(8)]		[Export("getRelationship")]		public bool GetRelationship(UnsafePointer<NSURLRelationship> outRelationship, NSURL ofDirectoryAtURL, NSURL toItemAtURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Determines the type of relationship that exists between a system directory and the specified item.		/// </summary>		/// <param name="outRelationship">A pointer to a variable in which to put the relationship between directoryURL and otherURL. For a list of possible values, see NSURLRelationship.</param>		/// <param name="ofDirectory">The search path directory. For a list of possible values, see NSSearchPathDirectory.</param>		/// <param name="inDomain">The file system domain to search. Specify 0 for this parameter if you want the file manager to choose the domain that is most appropriate for the specified url.</param>		/// <param name="toItemAtURL">The URL of the file or directory whose relationship to directoryURL is being tested. This parameter must not be nil.</param>		/// <param name="error">On input, a pointer to an error object. If an error occurs, this pointer is set to an actual error object containing the error information. You may specify nil for this parameter if you do not want the error information.</param>		[iOSVersion(8)]		[Export("getRelationship")]		public bool GetRelationship(UnsafePointer<NSURLRelationship> outRelationship, NSSearchPathDirectory ofDirectory, NSSearchPathDomainMask inDomain, NSURL toItemAtURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Returns a C-string representation of a given path that properly encodes Unicode strings for use by the file system.		/// </summary>		/// <param name="path">A string object containing a path to a file. This parameter must not be nil or contain the empty string.</param>		[iOSVersion(2)]		[Export("fileSystemRepresentationWithPath")]		public ConstUnsafePointer<Int8> FileSystemRepresentationWithPath(string path) { return default(ConstUnsafePointer<Int8>); }				/// <summary>		/// Returns an NSString object whose contents are derived from the specified C-string path.		/// </summary>		/// <param name="@string">A C string representation of a pathname.</param>		/// <param name="length">The number of characters in string.</param>		[iOSVersion(2)]		[Export("stringWithFileSystemRepresentation")]		public string StringWithFileSystemRepresentation(ConstUnsafePointer<Int8> @string, int length) { return default(string); }				/// <summary>		/// Changes the path of the current working directory to the specified path.		/// </summary>		/// <param name="path">The path of the directory to which to change.</param>		[iOSVersion(2)]		[Export("changeCurrentDirectoryPath")]		public bool ChangeCurrentDirectoryPath(string path) { return default(bool); }				/// <summary>		/// An opaque token that represents the current user’s iCloud identity (read-only)		/// </summary>		[iOSVersion(6)]		[Export("ubiquityIdentityToken")]		public protocol<NSCoding, NSCopying, NSObjectProtocol> UbiquityIdentityToken { get; private set; }				/// <summary>		/// The delegate of the file manager object.		/// </summary>		[iOSVersion(2)]		[Export("delegate")]		public NSFileManagerDelegate Delegate { get; set; }				/// <summary>		/// The path to the program’s current directory. (read-only)		/// </summary>		[iOSVersion(2)]		[Export("currentDirectoryPath")]		public string CurrentDirectoryPath { get; private set; }				/// <summary>		/// Specifies the version of the Foundation framework in which NSFileManager first supported resource forks.		/// </summary>		public int NSFoundationVersionWithFileManagerResourceForkSupport { get; set; }	}	/// <summary>	/// Options for enumerating mounted volumes with the mountedVolumeURLsIncludingResourceValuesForKeys:options: method.	/// </summary>	[iOSVersion(4)]	public enum NSVolumeEnumerationOptions	{		/// <summary>		/// The enumeration skips hidden volumes.		/// </summary>		[iOSVersion(4)]		SkipHiddenVolumes,		/// <summary>		/// The enumeration produces file reference URLs rather than path-based URLs.		/// </summary>		[iOSVersion(4)]		ProduceFileReferenceURLs,	}	/// <summary>	/// Options for enumerating the contents of directories with the contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error: method.	/// </summary>	[iOSVersion(4)]	public enum NSDirectoryEnumerationOptions	{		/// <summary>		/// Perform a shallow enumeration; do not descend into directories.		/// </summary>		[iOSVersion(4)]		SkipsSubdirectoryDescendants,		/// <summary>		/// Do not descend into packages.		/// </summary>		[iOSVersion(4)]		SkipsPackageDescendants,		/// <summary>		/// Do not enumerate hidden files.		/// </summary>		[iOSVersion(4)]		SkipsHiddenFiles,	}	/// <summary>	/// The constants specify the replacement behavior in replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:.	/// </summary>	[iOSVersion(4)]	public enum NSFileManagerItemReplacementOptions	{		/// <summary>		/// Causes replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error: to use metadata from the new item only and not to attempt to preserve metadata from the original item.		/// </summary>		[iOSVersion(4)]		UsingNewMetadataOnly,		/// <summary>		/// Causes replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error: to leave the backup item in place after a successful replacement. The default behavior is to remove the item.		/// </summary>		[iOSVersion(4)]		WithoutDeletingBackupItem,	}}
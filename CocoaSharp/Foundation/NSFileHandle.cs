using ObjectiveC;using System;using SwiftSharp.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// The NSFileHandle class is an object-oriented wrapper for a file descriptor. You use file handle objects to access data associated with files, sockets, pipes, and devices. For files, you can read, write, and seek within the file. For sockets, pipes, and devices, you can use a file handle object to monitor the device and process data asynchronously.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSFileHandle_Class/index.html#//apple_ref/occ/cl/NSFileHandle"/>    [iOSVersion(2)]    public class NSFileHandle : NSObject//, AnyObject, NSCoding, NSObjectProtocol, NSSecureCoding    {        /// <summary>        /// Returns a file handle initialized for reading the file, device, or named socket at the specified path.        /// </summary>        /// <param name="forReadingAtPath">The path to the file, device, or named socket to access.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSFileHandle(string forReadingAtPath) { }                /// <summary>        /// Returns a file handle initialized for reading the file, device, or named socket at the specified URL.        /// </summary>        /// <param name="url">The URL of the file, device, or named socket to access.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>        [iOSVersion(4)]        [Export("fileHandleForReadingFromURL")]        public static NSFileHandle FileHandleForReadingFromURL(NSURL url, NSErrorPointer error) { return default(NSFileHandle); }                /// <summary>        /// Returns a file handle initialized for writing to the file, device, or named socket at the specified path.        /// </summary>        /// <param name="forWritingAtPath">The path to the file, device, or named socket to access.</param>        /// <param name="NAME_YOUR_PARAMS">DO NOT USE THIS PARAMETER - Instead make sure to name the parameters you're using.</param>        [iOSVersion(2)]        [Export("convenience init")]        [IgnoreParameters("NAME_YOUR_PARAMS")]        public NSFileHandle(string forWritingAtPath, bool NAME_YOUR_PARAMS = false) { }                /// <summary>        /// Returns a file handle initialized for writing to the file, device, or named socket at the specified URL.        /// </summary>        /// <param name="url">The URL of the file, device, or named socket to access.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>        [iOSVersion(4)]        [Export("fileHandleForWritingToURL")]        public static NSFileHandle FileHandleForWritingToURL(NSURL url, NSErrorPointer error) { return default(NSFileHandle); }                /// <summary>        /// Returns a file handle initialized for reading and writing to the file, device, or named socket at the specified path.        /// </summary>        /// <param name="forUpdatingAtPath">The path to the file, device, or named socket to access.</param>        /// <param name="NAME_YOUR_PARAMS">DO NOT USE THIS PARAMETER - Instead make sure to name the parameters you're using.</param>        [iOSVersion(2)]        [Export("convenience init")]        [IgnoreParameters("NAME_YOUR_PARAMS")]        public NSFileHandle(string forUpdatingAtPath, int NAME_YOUR_PARAMS = 0) { }                /// <summary>        /// Returns a file handle initialized for reading and writing to the file, device, or named socket at the specified URL.        /// </summary>        /// <param name="url">The URL of the file, device, or named socket to access.</param>        /// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>        [iOSVersion(4)]        [Export("fileHandleForUpdatingURL")]        public static NSFileHandle FileHandleForUpdatingURL(NSURL url, NSErrorPointer error) { return default(NSFileHandle); }                /// <summary>        /// Returns the file handle associated with the standard error file.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithStandardError")]        public static NSFileHandle FileHandleWithStandardError() { return default(NSFileHandle); }                /// <summary>        /// Returns the file handle associated with the standard input file.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithStandardInput")]        public static NSFileHandle FileHandleWithStandardInput() { return default(NSFileHandle); }                /// <summary>        /// Returns the file handle associated with the standard output file.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithStandardOutput")]        public static NSFileHandle FileHandleWithStandardOutput() { return default(NSFileHandle); }                /// <summary>        /// Returns a file handle associated with a null device.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithNullDevice")]        public static NSFileHandle FileHandleWithNullDevice() { return default(NSFileHandle); }                /// <summary>        /// Initializes and returns a file handle object associated with the specified file descriptor.        /// </summary>        /// <param name="fileDescriptor">The POSIX file descriptor with which to initialize the file handle. This descriptor represents an open file or socket that you created previously. For example, when creating a file handle for a socket, you would pass the value returned by the socket function.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSFileHandle(int fileDescriptor) { }                /// <summary>        /// Initializes and returns a file handle object associated with the specified file descriptor and deallocation policy.        /// </summary>        /// <param name="fileDescriptor">The POSIX file descriptor with which to initialize the file handle.</param>        /// <param name="closeOnDealloc">true if the returned file handle object should take ownership of the file descriptor and close it for you or false if you want to maintain ownership of the file descriptor.</param>        [iOSVersion(2)]        public NSFileHandle(int fileDescriptor, bool closeOnDealloc) { }                /// <summary>        /// Synchronously reads the available data up to the end of file or maximum number of bytes.        /// </summary>        [iOSVersion(2)]        [Export("readDataToEndOfFile")]        public NSData ReadDataToEndOfFile() { return default(NSData); }                /// <summary>        /// Synchronously reads data up to the specified number of bytes.        /// </summary>        /// <param name="length">The number of bytes to read from the receiver.</param>        [iOSVersion(2)]        [Export("readDataOfLength")]        public NSData ReadDataOfLength(int length) { return default(NSData); }                /// <summary>        /// Synchronously writes the specified data to the receiver.        /// </summary>        /// <param name="data">The data to be written.</param>        [iOSVersion(2)]        [Export("writeData")]        public void WriteData(NSData data) {  }                /// <summary>        /// Accepts a socket connection (for stream-type sockets only) in the background and creates a file handle for the “near” (client) end of the communications channel.        /// </summary>        [iOSVersion(2)]        [Export("acceptConnectionInBackgroundAndNotify")]        public void AcceptConnectionInBackgroundAndNotify() {  }                /// <summary>        /// Accepts a socket connection (for stream-type sockets only) in the background and creates a file handle for the “near” (client) end of the communications channel.        /// </summary>        /// <param name="modes">The runloop modes in which the connection accepted notification can be posted.</param>        [iOSVersion(2)]        [Export("acceptConnectionInBackgroundAndNotifyForModes")]        public void AcceptConnectionInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Reads from the file or communications channel in the background and posts a notification when finished.        /// </summary>        [iOSVersion(2)]        [Export("readInBackgroundAndNotify")]        public void ReadInBackgroundAndNotify() {  }                /// <summary>        /// Reads from the file or communications channel in the background and posts a notification when finished.        /// </summary>        /// <param name="modes">The runloop modes in which the read completion notification can be posted.</param>        [iOSVersion(2)]        [Export("readInBackgroundAndNotifyForModes")]        public void ReadInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Reads to the end of file from the file or communications channel in the background and posts a notification when finished.        /// </summary>        [iOSVersion(2)]        [Export("readToEndOfFileInBackgroundAndNotify")]        public void ReadToEndOfFileInBackgroundAndNotify() {  }                /// <summary>        /// Reads to the end of file from the file or communications channel in the background and posts a notification when finished.        /// </summary>        /// <param name="modes">The runloop modes in which the read completion notification can be posted.</param>        [iOSVersion(2)]        [Export("readToEndOfFileInBackgroundAndNotifyForModes")]        public void ReadToEndOfFileInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Asynchronously checks to see if data is available.        /// </summary>        [iOSVersion(2)]        [Export("waitForDataInBackgroundAndNotify")]        public void WaitForDataInBackgroundAndNotify() {  }                /// <summary>        /// Asynchronously checks to see if data is available.        /// </summary>        /// <param name="modes">The runloop modes in which the data available notification can be posted.</param>        [iOSVersion(2)]        [Export("waitForDataInBackgroundAndNotifyForModes")]        public void WaitForDataInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Puts the file pointer at the end of the file referenced by the receiver and returns the new file offset.        /// </summary>        [iOSVersion(2)]        [Export("seekToEndOfFile")]        public UInt64 SeekToEndOfFile() { return default(UInt64); }                /// <summary>        /// Moves the file pointer to the specified offset within the file represented by the receiver.        /// </summary>        /// <param name="offset">The offset to seek to.</param>        [iOSVersion(2)]        [Export("seekToFileOffset")]        public void SeekToFileOffset(UInt64 offset) {  }                /// <summary>        /// Disallows further access to the represented file or communications channel and signals end of file on communications channels that permit writing.        /// </summary>        [iOSVersion(2)]        [Export("closeFile")]        public void CloseFile() {  }                /// <summary>        /// Causes all in-memory data and attributes of the file represented by the receiver to be written to permanent storage.        /// </summary>        [iOSVersion(2)]        [Export("synchronizeFile")]        public void SynchronizeFile() {  }                /// <summary>        /// Truncates or extends the file represented by the receiver to a specified offset within the file and puts the file pointer at that position.        /// </summary>        /// <param name="offset">The offset within the file that will mark the new end of the file.</param>        [iOSVersion(2)]        [Export("truncateFileAtOffset")]        public void TruncateFileAtOffset(UInt64 offset) {  }                /// <summary>        /// The POSIX file descriptor associated with the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("fileDescriptor")]        public int FileDescriptor { get; private set; }                /// <summary>        /// The data currently available in the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("availableData")]        public NSData AvailableData { get; private set; }                /// <summary>        /// The block to use for reading the contents of the file handle asynchronously.        /// </summary>        [iOSVersion(5)]        [Export("readabilityHandler")]        public Action<NSFileHandle> ReadabilityHandler { get; set; }                /// <summary>        /// The block to use for writing the contents of the file handle asynchronously.        /// </summary>        [iOSVersion(5)]        [Export("writeabilityHandler")]        public Action<NSFileHandle> WriteabilityHandler { get; set; }                /// <summary>        /// The position of the file pointer within the file represented by the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("offsetInFile")]        public UInt64 OffsetInFile { get; private set; }    }    /// <summary>    /// The notification object is the NSFileHandle object that sent the notification. The userInfo dictionary contains the following information:    /// </summary>    [iOSVersion(2)]    public class NSFileHandleConnectionAcceptedNotification : NSNotification    {        public NSFileHandleConnectionAcceptedNotification() : base("", null) { }    }    /// <summary>    /// The notification object is the NSFileHandle object that sent the notification. This notification does not contain a userInfo dictionary.    /// </summary>    [iOSVersion(2)]    public class NSFileHandleDataAvailableNotification : NSNotification    {        public NSFileHandleDataAvailableNotification() : base("", null) { }    }    /// <summary>    /// The notification object is the NSFileHandle object that sent the notification. The userInfo dictionary contains the following information:    /// </summary>    [iOSVersion(2)]    public class NSFileHandleReadCompletionNotification : NSNotification    {        public NSFileHandleReadCompletionNotification() : base("", null) { }    }    /// <summary>    /// The notification object is the NSFileHandle object that sent the notification. The userInfo dictionary contains the following information:    /// </summary>    [iOSVersion(2)]    public class NSFileHandleReadToEndOfFileCompletionNotification : NSNotification    {        public NSFileHandleReadToEndOfFileCompletionNotification() : base("", null) { }    }}
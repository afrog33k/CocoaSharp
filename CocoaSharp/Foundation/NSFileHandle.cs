using ObjectiveC;using System;using SharpSwift.Attributes;using System.Collections.Generic;namespace Foundation{    /// <summary>    /// The NSFileHandle class is an object-oriented wrapper for a file descriptor. You use file handle objects to access data associated with files, sockets, pipes, and devices. For files, you can read, write, and seek within the file. For sockets, pipes, and devices, you can use a file handle object to monitor the device and process data asynchronously.    /// </summary>    /// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSFileHandle_Class/index.html#//apple_ref/occ/cl/NSFileHandle"/>    [iOSVersion(2)]    [Export("")]    public class NSFileHandle : NSObject//, AnyObject, CVarArgType, Equatable, Hashable, NSCoding, NSObjectProtocol, NSSecureCoding, Printable    {        public NSFileHandle() { }        /// <summary>        /// Returns the file handle associated with the standard error file.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithStandardError")]        public static NSFileHandle FileHandleWithStandardError() { return default(NSFileHandle); }                /// <summary>        /// Returns the file handle associated with the standard input file.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithStandardInput")]        public static NSFileHandle FileHandleWithStandardInput() { return default(NSFileHandle); }                /// <summary>        /// Returns the file handle associated with the standard output file.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithStandardOutput")]        public static NSFileHandle FileHandleWithStandardOutput() { return default(NSFileHandle); }                /// <summary>        /// Returns a file handle associated with a null device.        /// </summary>        [iOSVersion(2)]        [Export("fileHandleWithNullDevice")]        public static NSFileHandle FileHandleWithNullDevice() { return default(NSFileHandle); }                /// <summary>        /// Initializes and returns a file handle object associated with the specified file descriptor.        /// </summary>        /// <param name="fileDescriptor">The POSIX file descriptor with which to initialize the file handle. This descriptor represents an open file or socket that you created previously. For example, when creating a file handle for a socket, you would pass the value returned by the socket function.</param>        [iOSVersion(2)]        [Export("convenience init")]        public NSFileHandle(int fileDescriptor) { }                /// <summary>        /// Initializes and returns a file handle object associated with the specified file descriptor and deallocation policy.        /// </summary>        /// <param name="fileDescriptor">The POSIX file descriptor with which to initialize the file handle.</param>        /// <param name="closeOnDealloc">true if the returned file handle object should take ownership of the file descriptor and close it for you or false if you want to maintain ownership of the file descriptor.</param>        [iOSVersion(2)]        public NSFileHandle(int fileDescriptor, bool closeOnDealloc) { }                /// <summary>        /// Synchronously reads the available data up to the end of file or maximum number of bytes.        /// </summary>        [iOSVersion(2)]        [Export("readDataToEndOfFile")]        public virtual NSData ReadDataToEndOfFile() { return default(NSData); }                /// <summary>        /// Synchronously reads data up to the specified number of bytes.        /// </summary>        /// <param name="length">The number of bytes to read from the receiver.</param>        [iOSVersion(2)]        [Export("readDataOfLength")]        public virtual NSData ReadDataOfLength(int length) { return default(NSData); }                /// <summary>        /// Synchronously writes the specified data to the receiver.        /// </summary>        /// <param name="data">The data to be written.</param>        [iOSVersion(2)]        [Export("writeData")]        public virtual void WriteData(NSData data) {  }                /// <summary>        /// Accepts a socket connection (for stream-type sockets only) in the background and creates a file handle for the “near” (client) end of the communications channel.        /// </summary>        [iOSVersion(2)]        [Export("acceptConnectionInBackgroundAndNotify")]        public virtual void AcceptConnectionInBackgroundAndNotify() {  }                /// <summary>        /// Accepts a socket connection (for stream-type sockets only) in the background and creates a file handle for the “near” (client) end of the communications channel.        /// </summary>        /// <param name="modes">The runloop modes in which the connection accepted notification can be posted.</param>        [iOSVersion(2)]        [Export("acceptConnectionInBackgroundAndNotifyForModes")]        public virtual void AcceptConnectionInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Reads from the file or communications channel in the background and posts a notification when finished.        /// </summary>        [iOSVersion(2)]        [Export("readInBackgroundAndNotify")]        public virtual void ReadInBackgroundAndNotify() {  }                /// <summary>        /// Reads from the file or communications channel in the background and posts a notification when finished.        /// </summary>        /// <param name="modes">The runloop modes in which the read completion notification can be posted.</param>        [iOSVersion(2)]        [Export("readInBackgroundAndNotifyForModes")]        public virtual void ReadInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Reads to the end of file from the file or communications channel in the background and posts a notification when finished.        /// </summary>        [iOSVersion(2)]        [Export("readToEndOfFileInBackgroundAndNotify")]        public virtual void ReadToEndOfFileInBackgroundAndNotify() {  }                /// <summary>        /// Reads to the end of file from the file or communications channel in the background and posts a notification when finished.        /// </summary>        /// <param name="modes">The runloop modes in which the read completion notification can be posted.</param>        [iOSVersion(2)]        [Export("readToEndOfFileInBackgroundAndNotifyForModes")]        public virtual void ReadToEndOfFileInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Asynchronously checks to see if data is available.        /// </summary>        [iOSVersion(2)]        [Export("waitForDataInBackgroundAndNotify")]        public virtual void WaitForDataInBackgroundAndNotify() {  }                /// <summary>        /// Asynchronously checks to see if data is available.        /// </summary>        /// <param name="modes">The runloop modes in which the data available notification can be posted.</param>        [iOSVersion(2)]        [Export("waitForDataInBackgroundAndNotifyForModes")]        public virtual void WaitForDataInBackgroundAndNotifyForModes(AnyObject[] modes) {  }                /// <summary>        /// Puts the file pointer at the end of the file referenced by the receiver and returns the new file offset.        /// </summary>        [iOSVersion(2)]        [Export("seekToEndOfFile")]        public virtual UInt64 SeekToEndOfFile() { return default(UInt64); }                /// <summary>        /// Moves the file pointer to the specified offset within the file represented by the receiver.        /// </summary>        /// <param name="offset">The offset to seek to.</param>        [iOSVersion(2)]        [Export("seekToFileOffset")]        public virtual void SeekToFileOffset(UInt64 offset) {  }                /// <summary>        /// Disallows further access to the represented file or communications channel and signals end of file on communications channels that permit writing.        /// </summary>        [iOSVersion(2)]        [Export("closeFile")]        public virtual void CloseFile() {  }                /// <summary>        /// Causes all in-memory data and attributes of the file represented by the receiver to be written to permanent storage.        /// </summary>        [iOSVersion(2)]        [Export("synchronizeFile")]        public virtual void SynchronizeFile() {  }                /// <summary>        /// Truncates or extends the file represented by the receiver to a specified offset within the file and puts the file pointer at that position.        /// </summary>        /// <param name="offset">The offset within the file that will mark the new end of the file.</param>        [iOSVersion(2)]        [Export("truncateFileAtOffset")]        public virtual void TruncateFileAtOffset(UInt64 offset) {  }                /// <summary>        /// The POSIX file descriptor associated with the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("fileDescriptor")]        public int FileDescriptor { get; private set; }                /// <summary>        /// The data currently available in the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("availableData")]        public NSData AvailableData { get; private set; }                /// <summary>        /// The block to use for reading the contents of the file handle asynchronously.        /// </summary>        [iOSVersion(5)]        [Export("readabilityHandler")]        public Action<NSFileHandle> ReadabilityHandler { get; set; }                /// <summary>        /// The block to use for writing the contents of the file handle asynchronously.        /// </summary>        [iOSVersion(5)]        [Export("writeabilityHandler")]        public Action<NSFileHandle> WriteabilityHandler { get; set; }                /// <summary>        /// The position of the file pointer within the file represented by the receiver. (read-only)        /// </summary>        [iOSVersion(2)]        [Export("offsetInFile")]        public UInt64 OffsetInFile { get; private set; }    }    /// <summary>    /// This notification is posted when an NSFileHandle object establishes a socket connection between two processes, creates an NSFileHandle object for one end of the connection, and makes this object available to observers by putting it in the userInfo dictionary. To cause the posting of this notification, you must send either acceptConnectionInBackgroundAndNotify or acceptConnectionInBackgroundAndNotifyForModes: to an NSFileHandle object representing a server stream-type socket.     ///   The notification object is the NSFileHandle object that sent the notification. The userInfo dictionary contains the following information:    ///   Key    ///   Value     ///   NSFileHandleNotificationFileHandleItem    ///   The NSFileHandle object representing the “near” end of a socket connection    ///   @&quot;NSFileHandleError&quot;    ///   An NSNumber object containing an integer representing the UNIX-type error which occurred    /// </summary>    public class NSFileHandleConnectionAcceptedNotification : NSNotification    {        public NSFileHandleConnectionAcceptedNotification() : base("", null) { }    }    /// <summary>    /// This notification is posted when the file handle determines that data is currently available for reading in a file or at a communications channel. The observers can then issue the appropriate messages to begin reading the data. To cause the posting of this notification, you must send either waitForDataInBackgroundAndNotify or waitForDataInBackgroundAndNotifyForModes: to an appropriate NSFileHandle object.     ///   The notification object is the NSFileHandle object that sent the notification. This notification does not contain a userInfo dictionary.    /// </summary>    public class NSFileHandleDataAvailableNotification : NSNotification    {        public NSFileHandleDataAvailableNotification() : base("", null) { }    }    /// <summary>    /// This notification is posted when the file handle reads the data currently available in a file or at a communications channel. It makes the data available to observers by putting it in the userInfo dictionary. To cause the posting of this notification, you must send either readInBackgroundAndNotify or readInBackgroundAndNotifyForModes: to an appropriate NSFileHandle object.     ///   The notification object is the NSFileHandle object that sent the notification. The userInfo dictionary contains the following information:    ///   Key    ///   Value     ///   NSFileHandleNotificationDataItem    ///   An NSData object containing the available data read from a socket connection    ///   @&quot;NSFileHandleError&quot;    ///   An NSNumber object containing an integer representing the UNIX-type error which occurred    /// </summary>    public class NSFileHandleReadCompletionNotification : NSNotification    {        public NSFileHandleReadCompletionNotification() : base("", null) { }    }    /// <summary>    /// This notification is posted when the file handle reads all data in the file or, if a communications channel, until the other process signals the end of data. It makes the data available to observers by putting it in the userInfo dictionary. To cause the posting of this notification, you must send either readToEndOfFileInBackgroundAndNotify or readToEndOfFileInBackgroundAndNotifyForModes: to an appropriate NSFileHandle object.     ///   The notification object is the NSFileHandle object that sent the notification. The userInfo dictionary contains the following information:    ///   Key    ///   Value     ///   NSFileHandleNotificationDataItem    ///   An NSData object containing the available data read from a socket connection    ///   @&quot;NSFileHandleError&quot;    ///   An NSNumber object containing an integer representing the UNIX-type error which occurred    /// </summary>    public class NSFileHandleReadToEndOfFileCompletionNotification : NSNotification    {        public NSFileHandleReadToEndOfFileCompletionNotification() : base("", null) { }    }}
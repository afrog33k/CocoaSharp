using ObjectiveC;using System;using SwiftSharp.Attributes;using System.Collections.Generic;namespace Foundation{	/// <summary>	/// The NSFileWrapper class provides access to the attributes and contents of file-system nodes. A file-system node is a file, directory, or symbolic link. Instances of this class are known as file wrappers.	/// </summary>	/// <see cref="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/ApplicationKit/Classes/NSFileWrapper_Class/index.html#//apple_ref/occ/cl/NSFileWrapper"/>	[iOSVersion(4)]	public class NSFileWrapper : NSObject//, AnyObject, NSCoding, NSObjectProtocol	{		/// <summary>		/// Initializes a file wrapper instance whose kind is determined by the type of file-system node located by the URL.		/// </summary>		/// <param name="URL">URL of the file-system node the file wrapper is to represent.</param>		/// <param name="options">Option flags for reading the node located at url. See File Wrapper Reading Options for possible values.</param>		/// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>		[iOSVersion(4)]		public NSFileWrapper(NSURL URL, NSFileWrapperReadingOptions options, NSErrorPointer error) { }				/// <summary>		/// Initializes the receiver as a directory file wrapper, with a given file-wrapper list.		/// </summary>		/// <param name="directoryWithFileWrappers">Key-value dictionary of file wrappers with which to initialize the receiver. The dictionary must contain entries whose values are the file wrappers that are to become children and whose keys are filenames. See Working with Directory Wrappers in File System Programming Guide for more information about the file-wrapper list structure.</param>		[iOSVersion(4)]		public NSFileWrapper(Dictionary<NSObject, AnyObject> directoryWithFileWrappers) { }				/// <summary>		/// Initializes the receiver as a regular-file file wrapper.		/// </summary>		/// <param name="regularFileWithContents">Contents of the file.</param>		[iOSVersion(4)]		public NSFileWrapper(NSData regularFileWithContents) { }				/// <summary>		/// Initializes the receiver as a symbolic-link file wrapper that links to a specified file.		/// </summary>		/// <param name="symbolicLinkWithDestinationURL">URL of the file the file wrapper is to reference.</param>		[iOSVersion(4)]		public NSFileWrapper(NSURL symbolicLinkWithDestinationURL) { }				/// <summary>		/// Initializes the receiver as a regular-file file wrapper from given serialized data.		/// </summary>		/// <param name="serializedRepresentation">Serialized representation of a file wrapper in the format used for the NSFileContentsPboardType pasteboard type. Data of this format is returned by such methods as serializedRepresentation and RTFDFromRange:documentAttributes: (NSAttributedString).</param>		/// <param name="NAME_YOUR_PARAMS">DO NOT USE THIS PARAMETER - Instead make sure to name the parameters you're using.</param>		[iOSVersion(4)]		[IgnoreParameters("NAME_YOUR_PARAMS")]		public NSFileWrapper(NSData serializedRepresentation, bool NAME_YOUR_PARAMS = false) { }				/// <summary>		/// Adds a child file wrapper to the receiver, which must be a directory file wrapper.		/// </summary>		/// <param name="child">File wrapper to add to the directory.</param>		[iOSVersion(4)]		[Export("addFileWrapper")]		public string AddFileWrapper(NSFileWrapper child) { return default(string); }				/// <summary>		/// Removes a child file wrapper from the receiver, which must be a directory file wrapper.		/// </summary>		/// <param name="child">File wrapper to remove from the directory.</param>		[iOSVersion(4)]		[Export("removeFileWrapper")]		public void RemoveFileWrapper(NSFileWrapper child) {  }				/// <summary>		/// Creates a regular-file file wrapper with the given contents and adds it to the receiver, which must be a directory file wrapper.		/// </summary>		/// <param name="data">Contents for the new regular-file file wrapper.</param>		/// <param name="preferredFilename">Preferred filename for the new regular-file file wrapper.</param>		[iOSVersion(4)]		[Export("addRegularFileWithContents")]		public string AddRegularFileWithContents(NSData data, string preferredFilename) { return default(string); }				/// <summary>		/// Returns the dictionary key used by a directory to identify a given file wrapper.		/// </summary>		/// <param name="child">The child file wrapper for which you want the key.</param>		[iOSVersion(4)]		[Export("keyForFileWrapper")]		public string KeyForFileWrapper(NSFileWrapper child) { return default(string); }				/// <summary>		/// Indicates whether the contents of a file wrapper matches a directory, regular file, or symbolic link on disk.		/// </summary>		/// <param name="url">URL of the file-system node with which to compare the file wrapper.</param>		[iOSVersion(4)]		[Export("matchesContentsOfURL")]		public bool MatchesContentsOfURL(NSURL url) { return default(bool); }				/// <summary>		/// Recursively rereads the entire contents of a file wrapper from the specified location on disk.		/// </summary>		/// <param name="url">URL of the file-system node corresponding to the file wrapper.</param>		/// <param name="options">Option flags for reading the node located at url. See File Wrapper Reading Options for possible values.</param>		/// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>		[iOSVersion(4)]		[Export("readFromURL")]		public bool ReadFromURL(NSURL url, NSFileWrapperReadingOptions options, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Recursively writes the entire contents of a file wrapper to a given file-system URL.		/// </summary>		/// <param name="url">URL of the file-system node to which the file wrapper’s contents are written.</param>		/// <param name="options">Option flags for writing to the node located at url. See File Wrapper Writing Options for possible values.</param>		/// <param name="originalContentsURL">The location of a previous revision of the contents being written. The default implementation of this method attempts to avoid unnecessary I/O by writing hard links to regular files instead of actually writing out their contents when the contents have not changed.  The child file wrappers must return accurate values when sent the filename method for this to work. Use the NSFileWrapperWritingWithNameUpdating writing option to increase the likelihood of that.		///   Specify nil for this parameter if there is no earlier version of the contents or if you want to ensure that all the contents are written to files.</param>		/// <param name="error">If an error occurs, upon return contains an NSError object that describes the problem. Pass NULL if you do not want error information.</param>		[iOSVersion(4)]		[Export("writeToURL")]		public bool WriteToURL(NSURL url, NSFileWrapperWritingOptions options, NSURL originalContentsURL, NSErrorPointer error) { return default(bool); }				/// <summary>		/// Returns the file wrappers contained by a directory file wrapper.		/// </summary>		[iOSVersion(4)]		[Export("fileWrappers")]		public Dictionary<NSObject, AnyObject> FileWrappers { get; private set; }				/// <summary>		/// Provides the URL referenced by the receiver, which must be a symbolic-link file wrapper.		/// </summary>		[iOSVersion(4)]		[Export("symbolicLinkDestinationURL")]		public NSURL SymbolicLinkDestinationURL { get; private set; }				/// <summary>		/// Returns the contents of the file wrapper as an opaque collection of data.		/// </summary>		[iOSVersion(4)]		[Export("serializedRepresentation")]		public NSData SerializedRepresentation { get; private set; }				/// <summary>		/// Provides the filename of a file wrapper.		/// </summary>		[iOSVersion(4)]		[Export("filename")]		public string Filename { get; set; }				/// <summary>		/// Provides the preferred filename for a file wrapper.		/// </summary>		[iOSVersion(4)]		[Export("preferredFilename")]		public string PreferredFilename { get; set; }				/// <summary>		/// Returns a file wrapper’s file attributes.		/// </summary>		[iOSVersion(4)]		[Export("fileAttributes")]		public Dictionary<NSObject, AnyObject> FileAttributes { get; set; }				/// <summary>		/// Returns the contents of the file-system node associated with a regular-file file wrapper.		/// </summary>		[iOSVersion(4)]		[Export("regularFileContents")]		public NSData RegularFileContents { get; private set; }	}	/// <summary>	/// Reading options that can be set by the initWithURL:options:error: and readFromURL:options:error: methods.	/// </summary>	[iOSVersion(4)]	public enum NSFileWrapperReadingOptions	{		/// <summary>		/// If reading with this option succeeds, then subsequent invocations of fileWrappers, regularFileContents, symbolicLinkDestinationURL, and serializedRepresentation sent to the file wrapper and all its child file wrappers will fail and return nil only if an actual error occurs (for example, the volume has disappeared or the file server is unreachable)—not as a result of the user moving or deleting files.		/// For performance reasons, NSFileWrapper may not read the contents of some file packages immediately even when this option is chosen. For example, because the contents of bundles (not all file packages are bundles) are immutable to the user, NSFileWrapper may read the children of such a directory lazily.		/// You can use this option to take a snapshot of a file or folder for writing later. For example, an application like TextEdit can use this option when creating new file wrappers to represent attachments that the user creates by copying and pasting or dragging and dropping from the Finder to a TextEdit document. Don't use this option when reading a document file package, because that would cause unnecessarily bad performance. For example, an application wouldn't use this option when creating file wrappers to represent attachments as it's opening a document stored in a file package.		/// </summary>		[iOSVersion(4)]		Immediate,		/// <summary>		/// Whether file mapping for regular file wrappers is disallowed.		/// You can use this option to keep NSFileWrapper from memory-mapping files. This is useful if you want to make sure your application doesn't hold files open (mapped files are open files), therefore preventing the user from ejecting DVDs, unmounting disk partitions, or unmounting disk images. In OS X v10.6 and later, NSFileWrapper memory-maps files that are on internal drives only. It never memory-maps files on external drives or network volumes, regardless of whether this option is used.		/// </summary>		[iOSVersion(4)]		WithoutMapping,	}	/// <summary>	/// Writing options that can be set by the writeToURL:options:originalContentsURL:error: method.	/// </summary>	[iOSVersion(4)]	public enum NSFileWrapperWritingOptions	{		/// <summary>		/// Whether writing is done atomically.		/// You can use this option to ensure that, when overwriting a file package, the overwriting either completely succeeds or completely fails, with no possibility of leaving the file package in an inconsistent state. Because this option causes additional I/O, you shouldn't use it unnecessarily. For example, don't use this option in an override of -[NSDocument writeToURL:ofType:error:], because NSDocument safe-saving is already done atomically.		/// </summary>		[iOSVersion(4)]		Atomic,		/// <summary>		/// Whether descendant file wrappers are sent the setFilename: method if the writing succeeds.		/// This option is necessary when your application passes a URL in the originalContentsURL parameter to the writeToURL:options:originalContentsURL:error: method. Without using this option (and reusing child file wrappers properly), subsequent invocations of writeToURL:options:originalContentsURL:error: would not be able to reliably create hard links in a new file package, because the record of names in the old file package would be out of date.		/// </summary>		[iOSVersion(4)]		WithNameUpdating,	}}
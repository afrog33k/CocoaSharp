using CoreGraphics;
using ObjectiveC;using System;using SwiftSharp.Attributes;using Foundation;namespace UIKit{    //https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSLayoutManager_Class_TextKit/index.html#//apple_ref/occ/cl/NSLayoutManager    /// <summary>    /// An NSLayoutManager object coordinates the layout and display of characters held in an NSTextStorage object. It maps Unicode character codes to glyphs, sets the glyphs in a series of NSTextContainer objects, and displays them in a series of text view objects. In addition to its core function of laying out text, an NSLayoutManager object coordinates its text view objects, provides services to those text views to support editing paragraph styles, and handles the layout and display of text attributes not inherent in glyphs (such as underline or strikethrough). You can create a subclass of NSLayoutManager to handle additional text attributes, whether inherent or not.    /// </summary>    [iOSVersion(7)]    public class NSLayoutManager : NSObject    {        /// <summary>        /// The receiver’s text storage object.        /// </summary>        [iOSVersion(7)]        [Export("textStorage")]        public NSTextStorage TextStorage { get; set; }                /// <summary>        /// Appends the given text container to the series of text containers where the receiver arranges text.        /// </summary>        /// <param name="container">The text container to append.</param>        [iOSVersion(7)]        [Export("addTextContainer")]        public void AddTextContainer(NSTextContainer container) { }                /// <summary>        /// The receiver’s text containers. (read-only)        /// </summary>        [iOSVersion(7)]        [Export("textContainers")]        public AnyObject[] TextContainers { get; private set; }                /// <summary>        /// Inserts the given text container into the series of text containers at the given index.        /// </summary>        /// <param name="container">The text container to insert.</param>        /// <param name="atIndex">The index in the series of text containers at which to insert aTextContainer.</param>        [iOSVersion(7)]        [Export("insertTextContainer")]        public void InsertTextContainer(NSTextContainer container, int atIndex) { }                /// <summary>        /// Removes the text container at the given index and invalidates the layout as needed.        /// </summary>        /// <param name="index">The index of the text container to remove.</param>        [iOSVersion(7)]        [Export("removeTextContainerAtIndex")]        public void RemoveTextContainerAtIndex(int index) { }                /// <summary>        /// Sets text container where the glyphs in the given range are laid out.        /// </summary>        /// <param name="container">The text container to set.</param>        /// <param name="forGlyphRange">The range of glyphs to lay out.</param>        [iOSVersion(7)]        [Export("setTextContainer")]        public void SetTextContainer(NSTextContainer container, NSRange forGlyphRange) { }                /// <summary>        /// Invalidates the layout information, and possibly glyphs, for the given text container and all subsequent NSTextContainer objects.        /// </summary>        /// <param name="container">The text container whose layout is invalidated.</param>        [iOSVersion(7)]        [Export("textContainerChangedGeometry")]        public void TextContainerChangedGeometry(NSTextContainer container) { }                /// <summary>        /// Returns the container in which the given glyph is laid out and (optionally) by reference the whole range of glyphs that are in that container.        /// </summary>        /// <param name="glyphIndex">Index of a glyph in the returned container.</param>        /// <param name="effectiveRange">If not NULL, on output, points to the whole range of glyphs that are in the returned container.</param>        /// <returns>The text container in which the glyph at glyphIndex is laid out.</returns>        [iOSVersion(7)]        [Export("textContainerForGlyphAtIndex")]        public NSTextContainer TextContainerForGlyphAtIndex(int glyphIndex, CMutablePointer<NSRange> effectiveRange) { return null; }                /// <summary>        /// Returns the bounding rectangle for the glyphs laid out in the given text container.        /// </summary>        /// <param name="container">The text container in which the glyphs are laid out.</param>        /// <returns>The bounding rectangle of the glyphs in container.</returns>        [iOSVersion(7)]        [Export("usedRectForTextContainer")]        public CGRect UsedRectForTextContainer(NSTextContainer container) { return new CGRect(); }                /// <summary>        /// This layout manager’s delegate.        /// </summary>        [iOSVersion(7)]        [Export("delegate")]        public NSLayoutManagerDelegate Delegate { get; set; }                /// <summary>        /// Indicates whether noncontiguous layout is enabled or disabled.        /// </summary>        [iOSVersion(7)]        [Export("allowsNonContiguousLayout")]        public bool AllowsNonContiguousLayout { get; set; }                /// <summary>        /// Indicates whether the layout manager currently has any areas of noncontiguous layout. (read-only)        /// </summary>        [iOSVersion(7)]        [Export("hasNonContiguousLayout")]        public bool HasNonContiguousLayout { get; private set; }                /// <summary>        /// The current hyphenation threshold.        /// </summary>        [iOSVersion(7)]        [Export("hyphenationFactor")]        public CGFloat HyphenationFactor { get; set; }                /// <summary>        /// Specifies whether to substitute visible glyphs for control characters in layout.        /// </summary>        [iOSVersion(7)]        [Export("showsControlCharacters")]        public bool ShowsControlCharacters { get; set; }                /// <summary>        /// Specifies whether to substitute visible glyphs for whitespace and other typically invisible characters in layout.        /// </summary>        [iOSVersion(7)]        [Export("showsInvisibleCharacters")]        public bool ShowsInvisibleCharacters { get; set; }                /// <summary>        /// Indicates whether the receiver uses the leading provided in the font.        /// </summary>        [iOSVersion(7)]        [Export("usesFontLeading")]        public bool UsesFontLeading { get; set; }                /// <summary>        /// Invalidates display for the given character range.        /// </summary>        /// <param name="charRange">The character range for which display is invalidated.</param>        [iOSVersion(7)]        [Export("invalidateDisplayForCharacterRange")]        public void InvalidateDisplayForCharacterRange(NSRange charRange) { }                /// <summary>        /// Marks the glyphs in the given glyph range as needing display, as well as the appropriate regions of the NSTextView objects that display those glyphs (using the NSView method setNeedsDisplayInRect:).        /// </summary>        /// <param name="glyphRange">The range of glyphs to invalidate.</param>        [iOSVersion(7)]        [Export("invalidateDisplayForGlyphRange")]        public void InvalidateDisplayForGlyphRange(NSRange glyphRange) { }                /// <summary>        /// Invalidates the cached glyphs for the characters in the given character range, adjusts the character indices of all the subsequent glyphs by the change in length, and invalidates the new character range.        /// </summary>        /// <param name="charRange">The range of characters for which to invalidate glyphs.</param>        /// <param name="changeInLength">The number of characters added or removed.</param>        /// <param name="actualCharacterRange">If not NULL, on output, the actual range invalidated after any necessary expansion. This range can be larger than the range of characters given due to the effect of context on glyphs and layout.</param>        [iOSVersion(7)]        [Export("invalidateGlyphsForCharacterRange")]        public void InvalidateGlyphsForCharacterRange(NSRange charRange, int changeInLength, CMutablePointer<NSRange> actualCharacterRange) { }                /// <summary>        /// Invalidates the layout information for the glyphs mapped to the given range of characters.        /// </summary>        /// <param name="charRange">The range of characters to invalidate.</param>        /// <param name="actualCharacterRange">If not NULL, on output, the actual range invalidated after any necessary expansion.</param>        [iOSVersion(7)]        [Export("invalidateLayoutForCharacterRange")]        public void InvalidateLayoutForCharacterRange(NSRange charRange, CMutablePointer<NSRange> actualCharacterRange) { }                /// <summary>        /// Sent from the NSTextStorage method processEditing to notify the layout manager of an edit action.        /// </summary>        /// <param name="textStorage">The text storage object processing edits.</param>        /// <param name="edited">The types of edits done: NSTextStorageEditedAttributes, NSTextStorageEditedCharacters, or both.</param>        /// <param name="range">The range in the final string that was explicitly edited.</param>        /// <param name="changeInLength">The length delta for the editing changes.</param>        /// <param name="invalidatedRange">The range of characters that changed as a result of attribute fixing. This invalidated range is either equal to newCharRange or larger.</param>        [iOSVersion(7)]        [Export("processEditingForTextStorage")]        public void ProcessEditingForTextStorage(NSTextStorage textStorage, NSTextStorageEditActions edited, NSRange range, int changeInLength, NSRange invalidatedRange) { }                /// <summary>        /// Forces the receiver to generate glyphs for the specified character range, if it has not already done so.        /// </summary>        /// <param name="charRange">The character range for which glyphs are generated.</param>        [iOSVersion(7)]        [Export("ensureGlyphsForCharacterRange")]        public void EnsureGlyphsForCharacterRange(NSRange charRange) { }                /// <summary>        /// Forces the receiver to generate glyphs for the specified glyph range, if it has not already done so.        /// </summary>        /// <param name="glyphRange">The glyph range for which glyphs are generated.</param>        [iOSVersion(7)]        [Export("ensureGlyphsForGlyphRange")]        public void EnsureGlyphsForGlyphRange(NSRange glyphRange) { }                /// <summary>        /// Forces the receiver to perform layout for the specified area in the specified text container, if it has not already done so.        /// </summary>        /// <param name="bounds">The area for which layout is performed.</param>        /// <param name="inTextContainer">The text container containing the area for which layout is performed.</param>        [iOSVersion(7)]        [Export("ensureLayoutForBoundingRect")]        public void EnsureLayoutForBoundingRect(CGRect bounds, NSTextContainer inTextContainer) { }                /// <summary>        /// Forces the receiver to perform layout for the specified character range, if it has not already done so.        /// </summary>        /// <param name="charRange">The character range for which layout is performed.</param>        [iOSVersion(7)]        [Export("ensureLayoutForCharacterRange")]        public void EnsureLayoutForCharacterRange(NSRange charRange) { }                /// <summary>        /// Forces the receiver to perform layout for the specified glyph range, if it has not already done so.        /// </summary>        /// <param name="glyphRange">The glyph range for which layout is performed.</param>        [iOSVersion(7)]        [Export("ensureLayoutForGlyphRange")]        public void EnsureLayoutForGlyphRange(NSRange glyphRange) { }                /// <summary>        /// Forces the receiver to perform layout for the specified text container, if it has not already done so.        /// </summary>        /// <param name="container">The text container for which layout is performed.</param>        [iOSVersion(7)]        [Export("ensureLayoutForTextContainer")]        public void EnsureLayoutForTextContainer(NSTextContainer container) { }                /// <summary>        /// Stores the initial glyphs and glyph properties for a character range.        /// </summary>        /// <param name="glyphs">A pointer to the layout manager's glyph cache.</param>        /// <param name="properties">A pointer to a buffer containing glyph properties for the glyphs in the cache.</param>        /// <param name="characterIndexes">A pointer to the starting index for the characters in the text storage for which glyphs are generated.</param>        /// <param name="font">A font to override the font attributes in the text storage for the specified character range.</param>        /// <param name="forGlyphRange">The range of glyphs in the glyph cache to set.</param>        [iOSVersion(7)]        [Export("setGlyphs")]        public void SetGlyphs(CConstPointer<CGGlyph> glyphs, CConstPointer<NSGlyphProperty> properties, CConstPointer<int> characterIndexes, UIFont font, NSRange forGlyphRange) { }                /// <summary>        /// Returns the index in the text storage for the first character associated with the given glyph.        /// </summary>        /// <param name="glyphIndex">The index of the glyph for which to return the associated character.</param>        /// <returns>The index of the first character associated with the glyph at the specified index.</returns>        [iOSVersion(7)]        [Export("characterIndexForGlyphAtIndex")]        public int CharacterIndexForGlyphAtIndex(int glyphIndex) { return 0; }                /// <summary>        /// Fills a passed-in buffer with a sequence of glyphs.        /// </summary>        /// <param name="glyphRange">The range of glyphs to fill in.</param>        /// <param name="glyphs">On output, the sequence of glyphs in the given glyph range.</param>        /// <param name="properties">If not NULL, on output, the glyph properties corresponding to the filled-in glyphs.</param>        /// <param name="characterIndexes">If not NULL, on output, the indexes of the original characters corresponding to the given glyph range. Note that a glyph at index 1 is not necessarily mapped to the character at index 1, since a glyph may be for a ligature or accent.</param>        /// <param name="bidiLevels">If not NULL, on output, the direction of each glyph for bidirectional text. The values range from 0 to 61 as defined by Unicode Standard Annex #9. An even value means the glyph goes left-to-right, and an odd value means the glyph goes right-to-left.</param>        /// <returns>The number of glyphs returned in glyphBuffer.</returns>        [iOSVersion(7)]        [Export("getGlyphsInRange")]        public int GetGlyphsInRange(NSRange glyphRange, CMutablePointer<CGGlyph> glyphs, CMutablePointer<NSGlyphProperty> properties, CMutablePointer<int> characterIndexes, CMutablePointer<CUnsignedChar> bidiLevels) { return 0; }                /// <summary>        /// Returns the glyph at the given glyph index.        /// </summary>        /// <param name="glyphIndex">The index of a glyph in the receiver. This value must not exceed the bounds of the receiver’s glyph array.</param>        /// <returns>The glyph at glyphIndex.</returns>        [iOSVersion(7)]        [Export("glyphAtIndex")]        public CGGlyph GlyphAtIndex(int glyphIndex) { return null; }                /// <summary>        /// If the given index is valid, returns the glyph at that location and optionally returns a flag indicating whether the requested index is in range.        /// </summary>        /// <param name="glyphIndex">The index of the glyph to be returned.</param>        /// <param name="isValidIndex">If not NULL, on output, true if the requested index is in range; otherwise false.</param>        /// <returns>The glyph at the requested index, or NSNullGlyph if the requested index is out of the range {0, numberOfGlyphs}.</returns>        [iOSVersion(7)]        [Export("glyphAtIndex")]        public CGGlyph GlyphAtIndex(int glyphIndex, CMutablePointer<ObjCBool> isValidIndex) { return null; }                /// <summary>        /// Returns the index of the first glyph associated with the character at the specified index.        /// </summary>        /// <param name="charIndex">The index of the character for which to return the associated glyph.</param>        /// <returns>The index of the first glyph associated with the character at the specified index.</returns>        [iOSVersion(7)]        [Export("glyphIndexForCharacterAtIndex")]        public int GlyphIndexForCharacterAtIndex(int charIndex) { return 0; }                /// <summary>        /// Indicates whether the specified index refers to a valid glyph.        /// </summary>        /// <param name="glyphIndex">The index of a glyph in the receiver.</param>        /// <returns>true if the specified glyphIndex refers to a valid glyph, otherwise false.</returns>        [iOSVersion(7)]        [Export("isValidGlyphIndex")]        public bool IsValidGlyphIndex(int glyphIndex) { return false; }                /// <summary>        /// The number of glyphs in the receiver. (read-only)        /// </summary>        [iOSVersion(7)]        [Export("numberOfGlyphs")]        public int NumberOfGlyphs { get; private set; }                /// <summary>        /// Returns the glyph property associated with the glyph at the specified index.        /// </summary>        /// <param name="glyphIndex">The glyph whose glyph property is returned.</param>        /// <returns>The glyph property associated with the specified glyph. NSGlyphProperty lists the values that can be returned.</returns>        [iOSVersion(7)]        [Export("propertyForGlyphAtIndex")]
        public NSGlyphProperty PropertyForGlyphAtIndex(int glyphIndex) { return NSGlyphProperty.Null; }                /// <summary>        /// Sets the size at which the given glyph (assumed to be an attachment) is asked to draw in the given glyph range.        /// </summary>        /// <param name="attachmentSize">The glyph size to set.</param>        /// <param name="forGlyphRange">The attachment glyph’s position in the glyph stream.</param>        [iOSVersion(7)]        [Export("setAttachmentSize")]        public void SetAttachmentSize(CGSize attachmentSize, NSRange forGlyphRange) { }                /// <summary>        /// Specifies whether the given glyph exceeds the bounds of the line fragment where it’s laid out.        /// </summary>        /// <param name="flag">If true, sets the given glyph to draw outside its line fragment; if false, the glyph does not draw outside.</param>        /// <param name="forGlyphAtIndex">Index of the glyph to set.</param>        [iOSVersion(7)]        [Export("setDrawsOutsideLineFragment")]        public void SetDrawsOutsideLineFragment(bool flag, int forGlyphAtIndex) { }                /// <summary>        /// Sets the bounds and container for the extra line fragment.        /// </summary>        /// <param name="fragmentRect">The rectangle to set.</param>        /// <param name="usedRect">Indicates where the insertion point is drawn.</param>        /// <param name="textContainer">The text container where the rectangle is to be laid out.</param>        [iOSVersion(7)]        [Export("setExtraLineFragmentRect")]        public void SetExtraLineFragmentRect(CGRect fragmentRect, CGRect usedRect, NSTextContainer textContainer) { }                /// <summary>        /// Associates the given line fragment bounds with the given range of glyphs.        /// </summary>        /// <param name="fragmentRect">The rectangle of the line fragment.</param>        /// <param name="forGlyphRange">The range of glyphs to be associated with fragmentRect.</param>        /// <param name="usedRect">The portion of fragmentRect that actually contains glyphs or other marks that are drawn (including the text container’s line fragment padding. Must be equal to or contained within fragmentRect.</param>        [iOSVersion(7)]        [Export("setLineFragmentRect")]        public void SetLineFragmentRect(CGRect fragmentRect, NSRange forGlyphRange, CGRect usedRect) { }                /// <summary>        /// Sets the location for the first glyph of the given range.        /// </summary>        /// <param name="location">The location to which the first glyph is set, relative to the origin of the glyph’s line fragment origin.</param>        /// <param name="forStartOfGlyphRange">The glyphs whose location is set.</param>        [iOSVersion(7)]        [Export("setLocation")]        public void SetLocation(CGPoint location, NSRange forStartOfGlyphRange) { }                /// <summary>        /// Sets the glyph at the given index to be one that isn’t shown.        /// </summary>        /// <param name="flag">If true, the glyph is not shown; if false, it is shown.</param>        /// <param name="forGlyphAtIndex">Index of the glyph whose attribute is set.</param>        [iOSVersion(7)]        [Export("setNotShownAttribute")]        public void SetNotShownAttribute(bool flag, int forGlyphAtIndex) { }                /// <summary>        /// For a glyph corresponding to an attachment, returns the size for the attachment cell to occupy.        /// </summary>        /// <param name="glyphIndex">The index of the attachment glyph.</param>        /// <returns>The size for the attachment cell to occupy. Returns {-1.0, -1.0} if there is no attachment laid for the specified glyph.</returns>        [iOSVersion(7)]        [Export("attachmentSizeForGlyphAtIndex")]        public CGSize AttachmentSizeForGlyphAtIndex(int glyphIndex) { return new CGSize(); }                /// <summary>        /// Indicates whether the glyph draws outside of its line fragment rectangle.        /// </summary>        /// <param name="glyphIndex">Index of the glyph.</param>        /// <returns>true if the glyph at glyphIndex exceeds the bounds of the line fragment where it’s laid out; otherwise false.</returns>        [iOSVersion(7)]        [Export("drawsOutsideLineFragmentForGlyphAtIndex")]        public bool DrawsOutsideLineFragmentForGlyphAtIndex(int glyphIndex) { return false; }                /// <summary>        /// The rectangle defining the extra line fragment for the insertion point at the end of a text (either in an empty text or after a final paragraph separator). (read-only)        /// </summary>        [iOSVersion(7)]        [Export("extraLineFragmentRect")]        public CGRect ExtraLineFragmentRect { get; private set; }                /// <summary>        /// The text container that contains the extra line fragment rectangle. (read-only)        /// </summary>        [iOSVersion(7)]        [Export("extraLineFragmentTextContainer")]        public NSTextContainer ExtraLineFragmentTextContainer { get; private set; }                /// <summary>        /// The rectangle enclosing the insertion point drawn in the extra line fragment rectangle. (read-only)        /// </summary>        [iOSVersion(7)]        [Export("extraLineFragmentUsedRect")]        public CGRect ExtraLineFragmentUsedRect { get; private set; }                /// <summary>        /// Returns the index for the first character in the layout manager that has not been laid out.        /// </summary>        /// <returns>The character index.</returns>        [iOSVersion(7)]        [Export("firstUnlaidCharacterIndex")]        public int FirstUnlaidCharacterIndex() { return 0; }                /// <summary>        /// Returns the index for the first glyph in the layout manager that has not been laid out.        /// </summary>        /// <returns>The glyph index.</returns>        [iOSVersion(7)]        [Export("firstUnlaidGlyphIndex")]        public int FirstUnlaidGlyphIndex() { return 0; }                /// <summary>        /// Returns the index for the first character or glyph, or both, having invalid layout information.        /// </summary>        /// <param name="charIndex">If not NULL, on return, the index of the first character that has invalid layout information</param>        /// <param name="glyphIndex">If not NULL, on return, the index of the first glyph that has invalid layout information.</param>        [iOSVersion(7)]        [Export("getFirstUnlaidCharacterIndex")]        public void GetFirstUnlaidCharacterIndex(CMutablePointer<int> charIndex, CMutablePointer<int> glyphIndex) { }                /// <summary>        /// Returns the rectangle for the line fragment in which the given glyph is laid out and (optionally), by reference, the whole range of glyphs that are in that fragment.        /// </summary>        /// <param name="glyphIndex">The glyph for which to return the line fragment rectangle.</param>        /// <param name="effectiveRange">If not NULL, on output, the range for all glyphs in the line fragment.</param>        /// <returns>The line fragment in which the given glyph is laid out.</returns>        [iOSVersion(7)]        [Export("lineFragmentRectForGlyphAtIndex")]        public CGRect LineFragmentRectForGlyphAtIndex(int glyphIndex, CMutablePointer<NSRange> effectiveRange) { return new CGRect(); }                /// <summary>        /// Returns the usage rectangle for the line fragment in which the given glyph is laid and (optionally) by reference the whole range of glyphs that are in that fragment.        /// </summary>        /// <param name="glyphIndex">The glyph for which to return the line fragment used rectangle.</param>        /// <param name="effectiveRange">If not NULL, on output, the range for all glyphs in the line fragment.</param>        /// <returns>The used rectangle for the line fragment in which the given glyph is laid out.</returns>        [iOSVersion(7)]        [Export("lineFragmentUsedRectForGlyphAtIndex")]        public CGRect LineFragmentUsedRectForGlyphAtIndex(int glyphIndex, CMutablePointer<NSRange> effectiveRange) { return new CGRect(); }                /// <summary>        /// Returns the location for the given glyph within its line fragment.        /// </summary>        /// <param name="glyphIndex">The glyph whose location is returned.</param>        /// <returns>The location of the given glyph.</returns>        [iOSVersion(7)]        [Export("locationForGlyphAtIndex")]        public CGPoint LocationForGlyphAtIndex(int glyphIndex) { return null; }                /// <summary>        /// Indicates whether the glyph at the given index is one that isn’t shown.        /// </summary>        /// <param name="glyphIndex">Index of the glyph.</param>        /// <returns>true if the glyph at glyphIndex is not shown; otherwise false.</returns>        [iOSVersion(7)]        [Export("notShownAttributeForGlyphAtIndex")]        public bool NotShownAttributeForGlyphAtIndex(int glyphIndex) { return false; }                /// <summary>        /// Returns the range of truncated glyphs for a line fragment containing the specified index.        /// </summary>        /// <param name="glyphIndex">A glyph whose line fragment is tested.</param>        /// <returns>The range of truncated glyphs for a line fragment containing the specified glyph, or, when there is no truncation for the line fragment, {NSNotFound, 0}.</returns>        [iOSVersion(7)]        [Export("truncatedGlyphRangeInLineFragmentForGlyphAtIndex")]        public NSRange TruncatedGlyphRangeInLineFragmentForGlyphAtIndex(int glyphIndex) { return new NSRange(); }                /// <summary>        /// Returns a single bounding rectangle (in container coordinates) enclosing all glyphs and other marks drawn in the given text container for the given glyph range, including glyphs that draw outside their line fragment rectangles and text attributes such as underlining.        /// </summary>        /// <param name="glyphRange">The range of glyphs for which to return the bounding rectangle.</param>        /// <param name="inTextContainer">The text container in which the glyphs are laid out.</param>        /// <returns>The bounding rectangle enclosing the given range of glyphs.</returns>        [iOSVersion(7)]        [Export("boundingRectForGlyphRange")]        public CGRect BoundingRectForGlyphRange(NSRange glyphRange, NSTextContainer inTextContainer) { return new CGRect(); }                /// <summary>        /// Returns the index of the character falling under the given point, expressed in the given container's coordinate system.        /// </summary>        /// <param name="point">The point to test.</param>        /// <param name="inTextContainer">The text container within which the point is tested.</param>        /// <param name="fractionOfDistanceBetweenInsertionPoints">A fraction of the distance from the insertion point, logically before the given character to the next one.</param>        /// <returns>The index of the character falling under point.</returns>        [iOSVersion(7)]        [Export("characterIndexForPoint")]        public int CharacterIndexForPoint(CGPoint point, NSTextContainer inTextContainer, CMutablePointer<CGFloat> fractionOfDistanceBetweenInsertionPoints) { return 0; }                /// <summary>        /// Returns the range of characters that generated the glyphs in the given glyph range.        /// </summary>        /// <param name="glyphRange">The glyph range for which to return the character range.</param>        /// <param name="actualGlyphRange">If not NULL, on output, points to the full range of glyphs generated by the character range returned. This range may be identical or slightly larger than the requested glyph range. For example, if the text storage contains the character “Ö” and the glyph cache contains the two atomic glyphs “O” and “¨”, and if glyphRange encloses only the first or second glyph, then actualGlyphRange is set to enclose both glyphs.</param>        /// <returns>The range of characters that generated the glyphs in glyphRange.</returns>        [iOSVersion(7)]        [Export("characterRangeForGlyphRange")]        public NSRange CharacterRangeForGlyphRange(NSRange glyphRange, CMutablePointer<NSRange> actualGlyphRange) { return new NSRange(); }                /// <summary>        /// Enumerates enclosing rectangles for the given glyph range in the given text container.        /// </summary>        /// <param name="glyphRange">The glyph range for which to return enclosing rectangles.</param>        /// <param name="withinSelectedGlyphRange">Selected glyphs within glyphRange, which can affect the size of the rectangles. If not interested in selection rectangles, pass {NSNotFound, 0} as the selected range.</param>        /// <param name="inTextContainer">The text container in which the glyphs are laid out.</param>        /// <param name="usingBlock">The block to apply to the glyph range. The block has two arguments:           rect              The current enclosing rectangle.                stop              A reference to a Boolean value. The block can set the value to true to stop further processing of the array. The stop argument is an out-only argument. You should only set this Boolean to true within the block.</param>        [iOSVersion(7)]        [Export("enumerateEnclosingRectsForGlyphRange")]        public void EnumerateEnclosingRectsForGlyphRange(NSRange glyphRange, NSRange withinSelectedGlyphRange, NSTextContainer inTextContainer, Action<CGRect, CMutablePointer<ObjCBool>> usingBlock) { }                /// <summary>        /// Enumerates line fragments intersecting with the given glyph range.        /// </summary>        /// <param name="glyphRange">The glyph range for which to return line fragment rectangles.</param>        /// <param name="usingBlock">The block to apply to the glyph range. The block has five arguments:           rect              The current line fragment rectangle.                usedRect              The portion of the line fragment rectangle that actually contains glyphs or other marks that are drawn (including the text container’s line fragment padding).                textContainer              The text container in which the glyphs are laid out.                glyphRange              The range of glyphs laid out in the current line fragment.                 stop              A reference to a Boolean value. The block can set the value to true to stop further processing of the array. The stop argument is an out-only argument. You should only set this Boolean to true within the block.</param>        [iOSVersion(7)]        [Export("enumerateLineFragmentsForGlyphRange")]        public void EnumerateLineFragmentsForGlyphRange(NSRange glyphRange, Action<CGRect, CGRect, NSTextContainer, NSRange, CMutablePointer<ObjCBool>> usingBlock) { }                /// <summary>        /// This method is a primitive for glyphIndexForPoint:inTextContainer:fractionOfDistanceThroughGlyph:. You should always call the main method, not the primitives.        /// </summary>        /// <param name="point">The point for which to return the fractional distance through the underlying glyph, in container coordinates.</param>        /// <param name="inTextContainer">The container in which the glyph is laid out.</param>        /// <returns>The fraction of the distance, through the underlying glyph, of point.</returns>        [iOSVersion(7)]        [Export("fractionOfDistanceThroughGlyphForPoint")]        public CGFloat FractionOfDistanceThroughGlyphForPoint(CGPoint point, NSTextContainer inTextContainer) { return null; }                /// <summary>        /// Returns insertion points in bulk for a given line fragment.        /// </summary>        /// <param name="charIndex">The character index of one character within the line fragment.</param>        /// <param name="alternatePositions">If true, returns alternate, rather than primary, insertion points.</param>        /// <param name="inDisplayOrder">If true, returns insertion points in display, rather than logical, order.</param>        /// <param name="positions">On output, the positions of the insertion points, in the order specified.</param>        /// <param name="characterIndexes">On output, the indexes of the characters corresponding to the returned insertion points.</param>        /// <returns>The number of insertion points returned.</returns>        [iOSVersion(7)]        [Export("getLineFragmentInsertionPointsForCharacterAtIndex")]        public int GetLineFragmentInsertionPointsForCharacterAtIndex(int charIndex, bool alternatePositions, bool inDisplayOrder, CMutablePointer<CGFloat> positions, CMutablePointer<int> characterIndexes) { return 0; }                /// <summary>        /// This method is a primitive for glyphIndexForPoint:inTextContainer:fractionOfDistanceThroughGlyph:. You should always call the main method, not the primitives.        /// </summary>        /// <param name="point">The point for which to return the glyph, in coordinates of container.</param>        /// <param name="inTextContainer">The container in which the returned glyph is laid out.</param>        /// <returns>The index of the glyph falling under the given point, expressed in the given container's coordinate system.</returns>        [iOSVersion(7)]        [Export("glyphIndexForPoint")]        public int GlyphIndexForPoint(CGPoint point, NSTextContainer inTextContainer) { return 0; }                /// <summary>        /// Returns the index of the glyph falling under the given point, expressed in the given container's coordinate system.        /// </summary>        /// <param name="point">The point for which to return the glyph, in coordinates of container.</param>        /// <param name="inTextContainer">The container in which the returned glyph is laid out.</param>        /// <param name="fractionOfDistanceThroughGlyph">If not NULL, on output, the fraction of the distance between the location of the glyph returned and the location of the next glyph.</param>        /// <returns>The index of the glyph falling under the given point, expressed in the given container's coordinate system.</returns>        [iOSVersion(7)]        [Export("glyphIndexForPoint")]        public int GlyphIndexForPoint(CGPoint point, NSTextContainer inTextContainer, CMutablePointer<CGFloat> fractionOfDistanceThroughGlyph) { return 0; }                /// <summary>        /// Returns the smallest contiguous range for glyphs that are laid out wholly or partially within the given rectangle in the given text container.        /// </summary>        /// <param name="bounds">The bounding rectangle for which to return glyphs.</param>        /// <param name="inTextContainer">The text container in which the glyphs are laid out.</param>        /// <returns>The range of glyphs that would need to be displayed in order to draw all glyphs that fall (even partially) within the given bounding rectangle. The range returned can include glyphs that don’t fall inside or intersect bounds, although the first and last glyphs in the range always do. At most this method returns the glyph range for the whole container.</returns>        [iOSVersion(7)]        [Export("glyphRangeForBoundingRect")]        public NSRange GlyphRangeForBoundingRect(CGRect bounds, NSTextContainer inTextContainer) { return new NSRange(); }                /// <summary>        /// Returns the smallest contiguous range for glyphs that are laid out wholly or partially within the given rectangle in the given text container.        /// </summary>        /// <param name="bounds">The bounding rectangle for which to return glyphs.</param>        /// <param name="inTextContainer">The text container in which the glyphs are laid out.</param>        /// <returns>The range of glyphs that would need to be displayed in order to draw all glyphs that fall (even partially) within the given bounding rectangle. The range returned can include glyphs that don’t fall inside or intersect bounds, although the first and last glyphs in the range always do. At most this method returns the glyph range for the whole container.</returns>        [iOSVersion(7)]        [Export("glyphRangeForBoundingRectWithoutAdditionalLayout")]
        public NSRange GlyphRangeForBoundingRectWithoutAdditionalLayout(CGRect bounds, NSTextContainer inTextContainer) { return new NSRange(); }                /// <summary>        /// Returns the range of glyphs that are generated from the characters in the given character range.        /// </summary>        /// <param name="charRange">The character range for which to return the generated glyph range.</param>        /// <param name="actualCharacterRange">If not NULL, on output, points to the actual range of characters that fully define the glyph range returned. This range may be identical to or slightly larger than the requested character range. For example, if the text storage contains the characters &quot;O&quot; and &quot;¨“, and the glyph store contains the single precomposed glyph &quot;¨Ö”, and if charRange encloses only the first or second character, then actualCharRange is set to enclose both characters.</param>        /// <returns>The range of glyphs generated by charRange.</returns>        [iOSVersion(7)]        [Export("glyphRangeForCharacterRange")]
        public NSRange GlyphRangeForCharacterRange(NSRange charRange, CMutablePointer<NSRange> actualCharacterRange) { return new NSRange(); }                /// <summary>        /// Returns the range of glyphs laid out in the given text container.        /// </summary>        /// <param name="container">The text container in which the glyphs are laid out.</param>        /// <returns>The range of glyphs laid out in the given text container.</returns>        [iOSVersion(7)]        [Export("glyphRangeForTextContainer")]
        public NSRange GlyphRangeForTextContainer(NSTextContainer container) { return new NSRange(); }                /// <summary>        /// Returns the range for the glyphs around the given glyph that can be displayed using only their advancements from the font, without pairwise kerning or other adjustments to spacing.        /// </summary>        /// <param name="glyphIndex">Index of the glyph to test.</param>        /// <returns>The range of nominally spaced glyphs.</returns>        [iOSVersion(7)]        [Export("rangeOfNominallySpacedGlyphsContainingIndex")]
        public NSRange RangeOfNominallySpacedGlyphsContainingIndex(int glyphIndex) { return new NSRange(); }                /// <summary>        /// Draws background marks for the given glyph range, which must lie completely within a single text container.        /// </summary>        /// <param name="glyphsToShow">The range of glyphs for which the background is drawn.</param>        /// <param name="atPoint">The position of the text container in the coordinate system of the currently focused view.</param>        [iOSVersion(7)]        [Export("drawBackgroundForGlyphRange")]        public void DrawBackgroundForGlyphRange(NSRange glyphsToShow, CGPoint atPoint) { }                /// <summary>        /// Draws the glyphs in the given glyph range, which must lie completely within a single text container.        /// </summary>        /// <param name="glyphsToShow">The range of glyphs that are drawn.</param>        /// <param name="atPoint">The position of the text container in the coordinate system of the currently focused view.</param>        [iOSVersion(7)]        [Export("drawGlyphsForGlyphRange")]        public void DrawGlyphsForGlyphRange(NSRange glyphsToShow, CGPoint atPoint) { }                /// <summary>        /// Draws a strikethrough for the glyphs in a given range.        /// </summary>        /// <param name="glyphRange">The range of glyphs for which to draw a strikethrough. The range must belong to a single line fragment rectangle (as returned by lineFragmentRectForGlyphAtIndex:effectiveRange:).</param>        /// <param name="strikethroughType">The style of strikethrough to draw. This value is a mask derived from the value for NSUnderlineStyleAttributeName—for example, (NSUnderlinePatternDash | NSUnderlineStyleThick). Subclasses can define custom strikethrough styles.</param>        /// <param name="baselineOffset">Indicates how far above the text baseline the underline should be drawn.</param>        /// <param name="lineFragmentRect">The line fragment rectangle containing the glyphs to draw strikethrough for.</param>        /// <param name="lineFragmentGlyphRange">The range of all glyphs within lineRect.</param>        /// <param name="containerOrigin">The origin of the line fragment rectangle’s NSTextContainer in its NSTextView.</param>        [iOSVersion(7)]        [Export("drawStrikethroughForGlyphRange")]        public void DrawStrikethroughForGlyphRange(NSRange glyphRange, NSUnderlineStyle strikethroughType, CGFloat baselineOffset, CGRect lineFragmentRect, NSRange lineFragmentGlyphRange, CGPoint containerOrigin) { }                /// <summary>        /// Draws underlining for the glyphs in a given range.        /// </summary>        /// <param name="glyphRange">A range of glyphs, which must belong to a single line fragment rectangle (as returned by lineFragmentRectForGlyphAtIndex:effectiveRange:).</param>        /// <param name="underlineType">The style of underlining to draw. This value is a mask derived from the value for NSUnderlineStyleAttributeName—for example, (NSUnderlinePatternDash | NSUnderlineStyleThick). Subclasses can define custom underlining styles.</param>        /// <param name="baselineOffset">Specifies the distance from the bottom of the bounding box of the specified glyphs in the specified range to their baseline.</param>        /// <param name="lineFragmentRect">The line fragment rectangle containing the glyphs to draw underlining for.</param>        /// <param name="lineFragmentGlyphRange">The range of all glyphs within lineRect.</param>        /// <param name="containerOrigin">The origin of the NSTextContainer object containing lineRect, in text view coordinates.</param>        [iOSVersion(7)]        [Export("drawUnderlineForGlyphRange")]        public void DrawUnderlineForGlyphRange(NSRange glyphRange, NSUnderlineStyle underlineType, CGFloat baselineOffset, CGRect lineFragmentRect, NSRange lineFragmentGlyphRange, CGPoint containerOrigin) { }                /// <summary>        /// Fills background rectangles with a color.        /// </summary>        /// <param name="rectArray">The array of rectangles to fill.</param>        /// <param name="count">The number of rectangles in rectArray.</param>        /// <param name="forCharacterRange">The range of characters whose background rectangles are filled.</param>        /// <param name="color">The fill color.</param>        [iOSVersion(7)]        [Export("fillBackgroundRectArray")]        public void FillBackgroundRectArray(CConstPointer<CGRect> rectArray, int count, NSRange forCharacterRange, UIColor color) { }                /// <summary>        /// Renders the glyphs at the specified positions and attributes into the given graphics context.        /// </summary>        /// <param name="glyphs">The glyphs to draw; may contain embedded NULL bytes.</param>        /// <param name="positions">The positions at which to draw the glyphs. In the user space coordinate system.</param>        /// <param name="count">The number of glyphs.</param>        /// <param name="font">The font applied to the graphics state. This value can be different from the NSFontAttributeName value in the attributes argument because of various font substitutions that the system automatically executes.</param>        /// <param name="matrix">The affine transform mapping the text space coordinate system to the user space coordinate system. The tx and ty components of textMatrix are ignored since Quartz overrides them with the glyph positions.</param>        /// <param name="attributes">A dictionary of glyph attributes.</param>        /// <param name="inContext">If non-nil, graphicsContext is already configured according to the text attributes arguments: font, textMatrix, and attributes.</param>        [iOSVersion(7)]        [Export("showCGGlyphs")]        public void ShowCGGlyphs(CConstPointer<CGGlyph> glyphs, CConstPointer<CGPoint> positions, int count, UIFont font, CGAffineTransform matrix, NSDictionary attributes, CGContext inContext) { }                /// <summary>        /// Calculates and draws strikethrough for the glyphs in the given range.        /// </summary>        /// <param name="glyphRange">The range of glyphs for which to draw a strikethrough. The range must belong to a single line fragment rectangle (as returned by lineFragmentRectForGlyphAtIndex:effectiveRange:).</param>        /// <param name="strikethroughType">The style of underlining to draw. This value is a mask derived from the value for NSUnderlineStyleAttributeName—for example, (NSUnderlinePatternDash | NSUnderlineStyleThick | NSUnderlineByWordMask). Subclasses can define custom underlining styles.</param>        /// <param name="lineFragmentRect">The line fragment rectangle containing the glyphs to draw strikethrough for.</param>        /// <param name="lineFragmentGlyphRange">The range of all glyphs within lineRect.</param>        /// <param name="containerOrigin">The origin of the line fragment rectangle’s NSTextContainer in its NSTextView.</param>        [iOSVersion(7)]        [Export("strikethroughGlyphRange")]        public void StrikethroughGlyphRange(NSRange glyphRange, NSUnderlineStyle strikethroughType, CGRect lineFragmentRect, NSRange lineFragmentGlyphRange, CGPoint containerOrigin) { }                /// <summary>        /// Calculates subranges to be underlined for the glyphs in a given range and draws the underlining as appropriate.        /// </summary>        /// <param name="glyphRange">A range of glyphs, which must belong to a single line fragment rectangle (as returned by lineFragmentRectForGlyphAtIndex:effectiveRange:).</param>        /// <param name="underlineType">The style of underlining to draw. This value is a mask derived from the value for NSUnderlineStyleAttributeName, for example, (NSUnderlinePatternDash | NSUnderlineStyleThick | NSUnderlineByWordMask). Subclasses can define custom underlining styles.</param>        /// <param name="lineFragmentRect">The line fragment rectangle containing the glyphs to draw underlining for.</param>        /// <param name="lineFragmentGlyphRange">The range of all glyphs within that line fragment rectangle.</param>        /// <param name="containerOrigin">The origin of the line fragment rectangle’s NSTextContainer, in text view coordinates.</param>        [iOSVersion(7)]        [Export("underlineGlyphRange")]        public void UnderlineGlyphRange(NSRange glyphRange, NSUnderlineStyle underlineType, CGRect lineFragmentRect, NSRange lineFragmentGlyphRange, CGPoint containerOrigin) { }
    }

    /// <summary>
    /// Describes the text layout orientation.
    /// </summary>
    public enum NSTextLayoutOrientation
    {
        /// <summary>
        /// Lines rendered horizontally, extending from top to bottom
        /// </summary>
        [iOSVersion(7)]
        Horizontal,

        /// <summary>
        /// Lines rendered vertically, extending from right to left
        /// </summary>
        [iOSVersion(7)]
        Vertical,
    }

    /// <summary>
    /// Describes glyph properties.
    /// </summary>
    public enum NSGlyphProperty
    {
        /// <summary>
        /// Null glyph ignored for layout and display.
        /// </summary>
        [iOSVersion(7)]
        Null,

        /// <summary>
        /// Control character such as tab, attachment, and so on, that has associated special behavior.
        /// </summary>
        [iOSVersion(7)]
        ControlCharacter,

        /// <summary>
        /// Glyphs with elastic glyph width behavior such as whitespace.
        /// </summary>
        [iOSVersion(7)]
        Elastic,

        /// <summary>
        /// Glyphs with combining properties, typically characters in Unicode Mn class.
        /// </summary>
        [iOSVersion(7)]
        NonBaseCharacter,
    }

    /// <summary>
    /// Describes actions control characters can cause.
    /// </summary>
    public enum NSControlCharacterAction
    {
        /// <summary>
        /// Glyphs with this action are filtered out from layout (notShownAttributeForGlyphAtIndex: == YES for the glyph).
        /// </summary>
        [iOSVersion(7)]
        ZeroAdvancementAction,

        /// <summary>
        /// The width for a glyph with this action is determined by the delegate method layoutManager:boundingBoxForControlGlyphAtIndex:forTextContainer:proposedLineFragment:glyphPosition:characterIndex: if the method is implemented; otherwise, same as NSControlCharacterZeroAdvancementAction.
        /// </summary>
        [iOSVersion(7)]
        WhitespaceAction,

        /// <summary>
        /// Treated as a tab character.
        /// </summary>
        [iOSVersion(7)]
        HorizontalTabAction,

        /// <summary>
        /// Causes a line break.
        /// </summary>
        [iOSVersion(7)]
        LineBreakAction,

        /// <summary>
        /// Causes a paragraph break; firstLineHeadIndent is used for the following glyph.
        /// </summary>
        [iOSVersion(7)]
        ParagraphBreakAction,

        /// <summary>
        /// Causes container break.
        /// </summary>
        [iOSVersion(7)]
        ContainerBreakAction,
    }}
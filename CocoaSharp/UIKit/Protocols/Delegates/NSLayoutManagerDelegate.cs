using CoreGraphics;
using ObjectiveC;using System;using SwiftSharp.Attributes;using Foundation;namespace UIKit{    //https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/NSLayoutManagerDelegate_Protocol_TextKit/index.html#//apple_ref/occ/intf/NSLayoutManagerDelegate    /// <summary>    /// The NSLayoutManagerDelegate protocol defines the optional methods implemented by delegates of NSLayoutManager objects.    /// </summary>    [iOSVersion(7)]    public interface NSLayoutManagerDelegate    {        /// <summary>        /// Sent while determining the hyphenation point.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="shouldBreakLineByHyphenatingBeforeCharacterAtIndex">Index of the character delimiting the hyphenation point search.</param>        /// <returns>true if the current hyphenation point is acceptable; false if the layout manager should find the next hyphenation opportunity before charIndex.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]        bool LayoutManagerBreakLineByHyphenatingBeforeCharacterAtIndex(NSLayoutManager layoutManager, int shouldBreakLineByHyphenatingBeforeCharacterAtIndex);                /// <summary>        /// Sent while determining the soft line break point.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="shouldBreakLineByWordBeforeCharacterAtIndex">Index of the character delimiting the break point search.</param>        /// <returns>true if the current line break point is acceptable; false if the layout manager should find the next break point opportunity before charIndex.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        bool LayoutManagerBreakLineByWordBeforeCharacterAtIndex(NSLayoutManager layoutManager, int shouldBreakLineByWordBeforeCharacterAtIndex);                /// <summary>        /// Returns the spacing after the line ending with the given glyph index.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="lineSpacingAfterGlyphAtIndex">The index of the glyph at the end of the line.</param>        /// <param name="withProposedLineFragmentRect">The proposed line fragment rectangle for the current line.</param>        /// <returns>The line spacing after the current line.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]        CGFloat LayoutManagerLineSpacingAfterGlyphAtIndex(NSLayoutManager layoutManager, int lineSpacingAfterGlyphAtIndex, CGRect withProposedLineFragmentRect);                /// <summary>        /// Returns the paragraph spacing after the line ending with the given glyph index.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="paragraphSpacingAfterGlyphAtIndex">The index of the glyph at the end of the line.</param>        /// <param name="withProposedLineFragmentRect">The proposed line fragment rectangle for the current line.</param>        /// <returns>The parapgraph spacing after the current line.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]        CGFloat LayoutManagerParagraphSpacingAfterGlyphAtIndex(NSLayoutManager layoutManager, int paragraphSpacingAfterGlyphAtIndex, CGRect withProposedLineFragmentRect);                /// <summary>        /// Returns the paragraph spacing before the line starting with the given glyph index.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="paragraphSpacingBeforeGlyphAtIndex">The index of the glyph at the beginning of the line.</param>        /// <param name="withProposedLineFragmentRect">The proposed line fragment rectangle for the current line.</param>        /// <returns>The parapgraph spacing before the current line.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        CGFloat LayoutManagerParagraphSpacingBeforeGlyphAtIndex(NSLayoutManager layoutManager, int paragraphSpacingBeforeGlyphAtIndex, CGRect withProposedLineFragmentRect);                /// <summary>        /// Returns the bounding rectangle for the specified control glyph with the specified parameters.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="boundingBoxForControlGlyphAtIndex">The index of the control glyph in question.</param>        /// <param name="forTextContainer">The text container to use to calculate the position.</param>        /// <param name="proposedLineFragment">The proposed line fragment rectangle.</param>        /// <param name="glyphPosition">The position of the glyph in textContainer.</param>        /// <param name="characterIndex">The character index in textContainer.</param>        /// <returns>The bounding rectangle for the specified control glyph with the specified parameters.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        CGRect LayoutManagerBoundingBoxForControlGlyphAtIndex(NSLayoutManager layoutManager, int boundingBoxForControlGlyphAtIndex, NSTextContainer forTextContainer, CGRect proposedLineFragment, CGPoint glyphPosition, int characterIndex);                /// <summary>        /// Informs the delegate that the given layout manager has finished laying out text in the given text container.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="didCompleteLayoutForTextContainer">The text container in which layout is complete. If nil, if there aren’t enough containers to hold all the text; the delegate can use this information as a cue to add another text container.</param>        /// <param name="atEnd">If true, layoutManager is finished laying out its text—this also means that textContainer is the final text container used by the layout manager. Delegates can use this information to show an indicator or background or to enable or disable a button that forces immediate layout of text.</param>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        void LayoutManagerDidCompleteLayoutForTextContainer(NSLayoutManager layoutManager, NSTextContainer didCompleteLayoutForTextContainer, bool atEnd);                /// <summary>        /// Sent right before the layout manager invalidates layout due to the text container changing geometry.        /// </summary>        /// <param name="layoutManager">The layout manager invalidating layout.</param>        /// <param name="textContainer">The text container that changed geometry.</param>        /// <param name="didChangeGeometryFromSize">The size of the text container before it changed geometry.</param>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        void LayoutManagerWithTextContainer(NSLayoutManager layoutManager, NSTextContainer textContainer, CGSize didChangeGeometryFromSize);                /// <summary>        /// Enables customizing the initial glyph generation process.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="shouldGenerateGlyphs">A pointer to the layout manager's glyph cache.</param>        /// <param name="properties">A pointer to a buffer containing glyph properties for the glyphs in the cache.</param>        /// <param name="characterIndexes">A pointer to the starting index for the characters in the text storage for which glyphs are generated.</param>        /// <param name="font">A font to override the font attributes in the text storage for the specified character range.</param>        /// <param name="forGlyphRange">The range of glyphs in the glyph cache to set.</param>        /// <returns>The actual glyph range stored in this method. By returning 0, it can indicate for the layout manager to do the default processing.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        int LayoutManagerShouldGenerateGlyphs(NSLayoutManager layoutManager, CConstPointer<CGGlyph> shouldGenerateGlyphs, CConstPointer<NSGlyphProperty> properties, CConstPointer<int> characterIndexes, UIFont font, NSRange forGlyphRange);                /// <summary>        /// Returns the control character action for the control character at the given character index.        /// </summary>        /// <param name="layoutManager">The layout manager doing the layout.</param>        /// <param name="shouldUseAction">The proposed control character action for the character at the given index. Possible values are enumerated by NSControlCharacterAction.</param>        /// <param name="forControlCharacterAtIndex">The index of the control character for which the action is proposed.</param>        /// <returns>The control character action for the control character at the given index.</returns>        [iOSVersion(7)]        [Export("layoutManager")]        [Optional]
        NSControlCharacterAction LayoutManagerShouldUseAction(NSLayoutManager layoutManager, NSControlCharacterAction shouldUseAction, int forControlCharacterAtIndex);                /// <summary>        /// Informs the delegate that the given layout manager has invalidated layout information (not glyph information).        /// </summary>        /// <param name="sender">The layout manager that invalidated layout.</param>        [iOSVersion(7)]        [Export("layoutManagerDidInvalidateLayout")]        [Optional]        void LayoutManagerDidInvalidateLayout(NSLayoutManager sender);    }}
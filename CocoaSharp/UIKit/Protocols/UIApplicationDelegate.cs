using ObjectiveC;using System;using SwiftSharp.Attributes;using Foundation;namespace UIKit{	//https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/index.html#//apple_ref/occ/intf/UIApplicationDelegate	/// <summary>	/// The UIApplicationDelegate protocol defines methods that are called by the singleton UIApplication object in response to important events in the lifetime of your app. The app delegate works alongside the app object to ensure your app interacts properly with the system and with other apps. Specifically, the methods of the app delegate give you a chance to respond to important changes. For example, you use the methods of the app delegate to respond to state transitions, such as when your app moves from foreground to background execution, and to respond to incoming notifications. In many cases, the methods of the app delegate are the only way to receive these important notifications.	/// </summary>	[iOSVersion(2)]	public interface UIApplicationDelegate	{		/// <summary>		/// Tells the delegate that the launch process has begun but that state restoration has not yet occurred.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="willFinishLaunchingWithOptions">A dictionary indicating the reason the app was launched (if any). The contents of this dictionary may be empty in situations where the user launched the app directly. For information about the possible keys in this dictionary and how to handle them, see Launch Options Keys.</param>		/// <returns>false if the app cannot handle the URL resource, otherwise return true. The return value is ignored if the app is launched as a result of a remote notification.</returns>		[iOSVersion(6)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSDictionary willFinishLaunchingWithOptions);				/// <summary>		/// Tells the delegate that the launch process is almost done and the app is almost ready to run.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="didFinishLaunchingWithOptions">A dictionary indicating the reason the app was launched (if any). The contents of this dictionary may be empty in situations where the user launched the app directly. For information about the possible keys in this dictionary and how to handle them, see Launch Options Keys.</param>		/// <returns>false if the app cannot handle the URL resource, otherwise return true. The return value is ignored if the app is launched as a result of a remote notification.</returns>		[iOSVersion(3)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSDictionary didFinishLaunchingWithOptions);				/// <summary>		/// Tells the delegate that the app has become active.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(2)]		[Export("applicationDidBecomeActive")]		[Optional]		void ApplicationDidBecomeActive(UIApplication application);				/// <summary>		/// Tells the delegate that the app is about to become inactive.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(2)]		[Export("applicationWillResignActive")]		[Optional]		void ApplicationWillResignActive(UIApplication application);				/// <summary>		/// Tells the delegate that the app is now in the background.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(4)]		[Export("applicationDidEnterBackground")]		[Optional]		void ApplicationDidEnterBackground(UIApplication application);				/// <summary>		/// Tells the delegate that the app is about to enter the foreground.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(4)]		[Export("applicationWillEnterForeground")]		[Optional]		void ApplicationWillEnterForeground(UIApplication application);				/// <summary>		/// Tells the delegate when the app is about to terminate.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(2)]		[Export("applicationWillTerminate")]		[Optional]		void ApplicationWillTerminate(UIApplication application);				/// <summary>		/// The window to use when presenting a storyboard.		/// </summary>		[iOSVersion(5)]		[Export("window")]		[Optional]		UIWindow Window;				/// <summary>		/// Tells the app that it can begin a fetch operation if it has data to download.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="performFetchWithCompletionHandler">The block to execute when the download operation is complete. When calling this block, pass in the fetch result value that best describes the results of your download operation. You must call this handler and should do so as soon as possible. For a list of possible values, see the UIBackgroundFetchResult type.</param>		[iOSVersion(7)]		[Export("application")]		[Optional]		void Application(UIApplication application, Action<UIBackgroundFetchResult> performFetchWithCompletionHandler);				/// <summary>		/// Tells the delegate that events related to a URL session are waiting to be processed.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="handleEventsForBackgroundURLSession">The identifier of the URL session requiring attention. If your app was just launched, you can use this identifier to create a new NSURLSession object that can receive the events.</param>		/// <param name="completionHandler">The completion handler to call when you finish processing the events. Calling this completion handler lets the system know that your appâ€™s user interface is updated and a new snapshot can be taken.</param>		[iOSVersion(7)]		[Export("application")]		[Optional]		void Application(UIApplication application, string handleEventsForBackgroundURLSession, Action<> completionHandler);				/// <summary>		/// Tells the delegate that the app successfully registered with Apple Push Service (APS).		/// </summary>		/// <param name="application">The app object that initiated the remote-notification registration process.</param>		/// <param name="didRegisterForRemoteNotificationsWithDeviceToken">A token that identifies the device to APS. The token is an opaque data type because that is the form that the provider needs to submit to the APS servers when it sends a notification to a device. The APS servers require a binary format for performance reasons.   The size of a device token is 32 bytes.   Note that the device token is different from the uniqueIdentifier property of UIDevice because, for security and privacy reasons, it must change when the device is wiped.</param>		[iOSVersion(3)]		[Export("application")]		[Optional]		void Application(UIApplication application, NSData didRegisterForRemoteNotificationsWithDeviceToken);				/// <summary>		/// Sent to the delegate when Apple Push Service cannot successfully complete the registration process.		/// </summary>		/// <param name="application">The app object that initiated the remote-notification registration process.</param>		/// <param name="didFailToRegisterForRemoteNotificationsWithError">An NSError object that encapsulates information why registration did not succeed. The app can choose to display this information to the user.</param>		[iOSVersion(3)]		[Export("application")]		[Optional]		void Application(UIApplication application, NSError didFailToRegisterForRemoteNotificationsWithError);				/// <summary>		/// Tells the app that a push notification arrived that indicates there is data to be fetched.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="didReceiveRemoteNotification">A dictionary that contains information related to the remote notification, potentially including a badge number for the app icon, an alert sound, an alert message to display to the user, a notification identifier, and custom data. The provider originates it as a JSON-defined dictionary that iOS converts to an NSDictionary object; the dictionary may contain only property-list objects plus NSNull. For more information about the contents of the push notification dictionary, see Local and Push Notification Programming Guide.</param>		/// <param name="fetchCompletionHandler">The block to execute when the download operation is complete. When calling this block, pass in the fetch result value that best describes the results of your download operation. You must call this handler and should do so as soon as possible. For a list of possible values, see the UIBackgroundFetchResult type.</param>		[iOSVersion(7)]		[Export("application")]		[Optional]		void Application(UIApplication application, NSDictionary didReceiveRemoteNotification, Action<UIBackgroundFetchResult> fetchCompletionHandler);				/// <summary>		/// Tells the app delegate to perform the custom action specified by a push notification.		/// </summary>		/// <param name="application">The app object that received the remote notification.</param>		/// <param name="handleActionWithIdentifier">The identifier associated with the custom action.</param>		/// <param name="forRemoteNotification">A dictionary that contains information related to the remote notification. This dictionary originates from the provider as a JSON-defined dictionary, which iOS converts to an NSDictionary object before calling this method. The contents of the dictionary are the push notification payload, which consists only of property-list objects plus NSNull. For more information about the contents of the push notification dictionary, see Local and Push Notification Programming Guide.</param>		/// <param name="completionHandler">The block to execute when you are finished performing the specified action. You must call this block at the end of your method.</param>		[iOSVersion(8)]		[Export("application")]		[Optional]		void Application(UIApplication application, string handleActionWithIdentifier, NSDictionary forRemoteNotification, Action<> completionHandler);				/// <summary>		/// Tells the delegate that the running app received a remote notification.		/// </summary>		/// <param name="application">The app object that received the remote notification.</param>		/// <param name="didReceiveRemoteNotification">A dictionary that contains information related to the remote notification, potentially including a badge number for the app icon, an alert sound, an alert message to display to the user, a notification identifier, and custom data. The provider originates it as a JSON-defined dictionary that iOS converts to an NSDictionary object; the dictionary may contain only property-list objects plus NSNull.</param>		[iOSVersion(3)]		[Export("application")]		[Optional]		void Application(UIApplication application, NSDictionary didReceiveRemoteNotification);				/// <summary>		/// Sent to the delegate when a running app receives a local notification.		/// </summary>		/// <param name="application">The app object that received the local notification.</param>		/// <param name="didReceiveLocalNotification">A local notification that encapsulates details about the notification, potentially including custom data.</param>		[iOSVersion(4)]		[Export("application")]		[Optional]		void Application(UIApplication application, UILocalNotification didReceiveLocalNotification);				/// <summary>		/// Tells the delegate that the user selected a custom action from the alert panel of a local notification.		/// </summary>		/// <param name="application">The app object that received the local notification.</param>		/// <param name="handleActionWithIdentifier">The identifier associated with the custom action. This string corresponds to the identifier from the UILocalNotificationAction object that was used to configure the action in the local notification.</param>		/// <param name="forLocalNotification">The local notification object that was triggered.</param>		/// <param name="completionHandler">A block to call when you are finished performing the action.</param>		[iOSVersion(8)]		[Export("application")]		[Optional]		void Application(UIApplication application, string handleActionWithIdentifier, UILocalNotification forLocalNotification, Action<> completionHandler);				/// <summary>		/// Tells the delegate what types of notifications may be used to get the userâ€™s attention.		/// </summary>		/// <param name="application">The app object that registered the user notification settings.</param>		/// <param name="didRegisterUserNotificationSettings">The user notification settings that are available to your app. The settings in this object may be different than the ones you originally requested.</param>		[iOSVersion(8)]		[Export("application")]		[Optional]		void Application(UIApplication application, UIUserNotificationSettings didRegisterUserNotificationSettings);				/// <summary>		/// Tells the delegate when the app receives a memory warning from the system.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(2)]		[Export("applicationDidReceiveMemoryWarning")]		[Optional]		void ApplicationDidReceiveMemoryWarning(UIApplication application);				/// <summary>		/// Tells the delegate when there is a significant change in the time.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(2)]		[Export("applicationSignificantTimeChange")]		[Optional]		void ApplicationSignificantTimeChange(UIApplication application);				/// <summary>		/// Asks the delegate whether the appâ€™s state should be preserved.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="shouldSaveApplicationState">The keyed archiver into which you can put high-level state information.</param>		/// <returns>true if the appâ€™s state should be preserved or false if it should not.</returns>		[iOSVersion(6)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSCoder shouldSaveApplicationState);				/// <summary>		/// Asks the delegate whether the appâ€™s saved state information should be restored.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="shouldRestoreApplicationState">The keyed archiver containing the appâ€™s previously saved state information.</param>		/// <returns>true if the appâ€™s state should be restored or false if it should not.</returns>		[iOSVersion(6)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSCoder shouldRestoreApplicationState);				/// <summary>		/// Asks the delegate to provide the specified view controller.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="viewControllerWithRestorationIdentifierPath">An array of NSString objects corresponding to the restoration identifiers of the desired view controller and all of its ancestors in the view controller hierarchy. The last value in the array is the restoration identifier of the desired view controller. Earlier entries represent the restoration identifiers of its ancestors.</param>		/// <param name="coder">The keyed archiver containing the appâ€™s saved state information.</param>		/// <returns>The view controller object to use or nil if the app delegate does not supply this view controller. If this method returns nil, UIKit tries to find the view controller implicitly using the available restoration path and storyboard information.</returns>		[iOSVersion(6)]		[Export("application")]		[Optional]		UIViewController Application(UIApplication application, AnyObject[] viewControllerWithRestorationIdentifierPath, NSCoder coder);				/// <summary>		/// Tells your delegate to save any high-level state information at the beginning of the state preservation process.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="willEncodeRestorableStateWithCoder">The keyed archiver in which to write any state information.</param>		[iOSVersion(6)]		[Export("application")]		[Optional]		void Application(UIApplication application, NSCoder willEncodeRestorableStateWithCoder);				/// <summary>		/// Tells your delegate to restore any high-level state information as part of the state restoration process.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="didDecodeRestorableStateWithCoder">The keyed archiver containing the appâ€™s previously saved state information.</param>		[iOSVersion(6)]		[Export("application")]		[Optional]		void Application(UIApplication application, NSCoder didDecodeRestorableStateWithCoder);				/// <summary>		/// Asks the delegate to open a resource identified by URL.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="openURL">The URL resource to open. This resource can be a network resource or a file. For information about the Apple-registered URL schemes, see Apple URL Scheme Reference.</param>		/// <param name="sourceApplication">The bundle ID of the app that is requesting your app to open the URL (url).</param>		/// <param name="annotation">A property list object supplied by the source app to communicate information to the receiving app.</param>		/// <returns>true if the delegate successfully handled the request or false if the attempt to open the URL resource failed.</returns>		[iOSVersion(4.2)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSURL openURL, string sourceApplication, AnyObject annotation);				/// <summary>		/// Tells the delegate that the user wants to continue an activity in your app.		/// </summary>		/// <param name="application">The app continuing the user activity.</param>		/// <param name="willContinueUserActivityWithType">The type of activity to be continued.</param>		/// <returns>true if you notify the user that your app is about to continue the activity or false if you want iOS to notify the user.</returns>		[iOSVersion(8)]		[Export("application")]		[Optional]		bool Application(UIApplication application, string willContinueUserActivityWithType);				/// <summary>		/// Tells the delegate that the data for continuing an activity is available.		/// </summary>		/// <param name="application">The app continuing the user activity.</param>		/// <param name="continueUserActivity">The activity object containing the data associated with the task the user was performing. Use the data in this object to recreate what the user was doing.</param>		/// <param name="restorationHandler">A block to execute if your app creates or fetches objects to perform the task. Calling this block is optional and is only needed when specific objects are capable of continuing the activity. You can copy this block and call it at a later time. When calling a saved copy of the block, you must call it from the appâ€™s main thread. This block has no return value and takes the following parameter:           restorableObjects              An array of UIResponder or UIDocument objects representing objects you created or fetched in order to perform the operation. The system calls the restoreUserActivityState: method of each object in the array to give it a chance to perform the operation.</param>		/// <returns>true to indicate that your app handled the activity or false to let iOS know that your app did not handle the activity.</returns>		[iOSVersion(8)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSUserActivity continueUserActivity, Action<AnyObject[]> restorationHandler);				/// <summary>		/// Tells the delegate that the activity could not be continued.		/// </summary>		/// <param name="application">The app that attempted to continue the activity.</param>		/// <param name="didFailToContinueUserActivityWithType">The activity type that was attempted.</param>		/// <param name="error">An error object indicating the reason for the failure.</param>		[iOSVersion(8)]		[Export("application")]		[Optional]		void Application(UIApplication application, string didFailToContinueUserActivityWithType, NSError error);				/// <summary>		/// Tells the delegate when the interface orientation of the status bar is about to change.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="willChangeStatusBarOrientation">A constant that indicates the new orientation of the appâ€™s user interface; see Monitoring App State Changes for details.</param>		/// <param name="duration">The duration of the animation to the new orientation, in seconds.</param>		[iOSVersion(2)]		[Export("application")]		[Optional]		void Application(UIApplication application, UIinterfaceOrientation willChangeStatusBarOrientation, NSTimeinterval duration);				/// <summary>		/// Tells the delegate when the interface orientation of the status bar has changed.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="didChangeStatusBarOrientation">A constant that indicates the previous orientation of the appâ€™s user interface; see Monitoring App State Changes for details.</param>		[iOSVersion(2)]		[Export("application")]		[Optional]		void Application(UIApplication application, UIinterfaceOrientation didChangeStatusBarOrientation);				/// <summary>		/// Tells the delegate when the frame of the status bar is about to change.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="willChangeStatusBarFrame">The changed frame of the status bar, in screen coordinates.</param>		[iOSVersion(2)]		[Export("application")]		[Optional]		void Application(UIApplication application, CGRect willChangeStatusBarFrame);				/// <summary>		/// Tells the delegate when the frame of the status bar has changed.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="didChangeStatusBarFrame">The previous frame of the status bar, in screen coordinates.</param>		[iOSVersion(2)]		[Export("application")]		[Optional]		void Application(UIApplication application, CGRect didChangeStatusBarFrame);				/// <summary>		/// Tells the delegate that the protected files are about to become unavailable.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(4)]		[Export("applicationProtectedDataWillBecomeUnavailable")]		[Optional]		void ApplicationProtectedDataWillBecomeUnavailable(UIApplication application);				/// <summary>		/// Tells the delegate that protected files are available now.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(4)]		[Export("applicationProtectedDataDidBecomeAvailable")]		[Optional]		void ApplicationProtectedDataDidBecomeAvailable(UIApplication application);				/// <summary>		/// Asks the delegate for the interface orientations to use for the view controllers in the specified window.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="supportedinterfaceOrientationsForWindow">The window whose interface orientations you want to retrieve.</param>		/// <returns>A bit mask of the UIinterfaceOrientationMask constants that indicate the orientations to use for the view controllers.</returns>		[iOSVersion(6)]		[Export("application")]		[Optional]		int Application(UIApplication application, UIWindow supportedinterfaceOrientationsForWindow);				/// <summary>		/// Tells the delegate when the app has finished launching.		/// </summary>		/// <param name="application">The singleton app object.</param>		[iOSVersion(2)]		[Export("applicationDidFinishLaunching")]		[Optional]		void ApplicationDidFinishLaunching(UIApplication application);				/// <summary>		/// Asks the delegate to open a resource identified by URL.						 Use the application:openURL:sourceApplication:annotation: method instead.		/// </summary>		/// <param name="application">The singleton app object.</param>		/// <param name="handleOpenURL">A object representing a URL (Universal Resource Locator). See the appendix of App Programming Guide for iOS for Apple-registered schemes for URLs.</param>		/// <returns>true if the delegate successfully handled the request; false if the attempt to handle the URL failed.</returns>		[iOSVersion(2)]		[Export("application")]		[Optional]		bool Application(UIApplication application, NSURL handleOpenURL);				/// <summary>		/// Keys used to access values in the launch options dictionary passed to the application:willFinishLaunchingWithOptions: and application:didFinishLaunchingWithOptions: methods of the app delegate.		/// </summary>				/// <summary>		/// The presence of this key indicates that the app was launched in order to open a URL. The value of this key is an NSURL object containing the URL to open.		/// </summary>		[iOSVersion(3)]		string UIApplicationLaunchOptionsURLKey;				/// <summary>		/// The presence of this key identifies the app that requested the launch of your app. The value of this key is an NSString object that represents the bundle ID of the app that made the request.		/// </summary>		[iOSVersion(3)]		string UIApplicationLaunchOptionsSourceApplicationKey;				/// <summary>		/// The presence of this key indicates that a remote notification is available for the app to process. The value of this key is an NSDictionary containing the payload of the remote notification. See the description of application:didReceiveRemoteNotification: for further information about handling remote notifications.		/// </summary>		[iOSVersion(3)]		string UIApplicationLaunchOptionsRemoteNotificationKey;				/// <summary>		/// The presence of this key indicates that custom data was provided by the app that requested the opening of the URL. The value of this key is a property-list object containing the custom data. The same object is also passed to the annotation parameter of the application:openURL:sourceApplication:annotation: method. The contents of this property-list object are specific to the app that made the request.		/// </summary>		[iOSVersion(3.2)]		string UIApplicationLaunchOptionsAnnotationKey;				/// <summary>		/// The presence of this key indicates that a local notification is available for the app to process. The value of this key is the UILocalNotification object that was triggered. For additional information about handling local notifications, see the application:didReceiveLocalNotification: method.		/// </summary>		[iOSVersion(4)]		string UIApplicationLaunchOptionsLocalNotificationKey;				/// <summary>		/// The presence of this key indicates that the app was launched in response to an incoming location event. The value of this key is an NSNumber object containing a Boolean value. You should use the presence of this key as a signal to create a CLLocationManager object and start location services again. Location data is delivered only to the location manager delegate and not using this key.		/// </summary>		[iOSVersion(4)]		string UIApplicationLaunchOptionsLocationKey;				/// <summary>		/// The presence of this key indicates that newly downloaded Newsstand assets are available for your app. The value of this key is an array of string identifiers that identify the NKAssetDownload objects corresponding to the assets. Although you can use the identifiers for cross-checking purposes, you should obtain the definitive array of NKAssetDownload objects (representing asset downloads in progress or in error) through the downloadingAssets property of the NKLibrary object representing the Newsstand appâ€™s library.		/// </summary>		[iOSVersion(5)]		string UIApplicationLaunchOptionsNewsstandDownloadsKey;				/// <summary>		/// The presence of this key indicates that the app previously had one or more CBCentralManager objects and was relaunched by the Bluetooth system to continue actions associated with those objects. The value of this key is an NSArray object containing one or more NSString objects.		/// </summary>		[iOSVersion(7)]		string UIApplicationLaunchOptionsBluetoothCentralsKey;				/// <summary>		/// The presence of this key indicates that the app previously had one or more CBPeripheralManager objects and was relaunched by the Bluetooth system to continue actions associated with those objects. The value of this key is an NSArray object containing one or more NSString objects.		/// </summary>		[iOSVersion(7)]		string UIApplicationLaunchOptionsBluetoothPeripheralsKey;	}}